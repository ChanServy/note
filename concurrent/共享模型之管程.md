---
title: 共享模型之管程
tags: 并发
categories: 并发
cover: https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/head/java.png
sticky: 6
abbrlink: 979875819
date: 2021-11-20 09:58:46
---

## 1. 共享带来的问题

**临界区 Critical Section** 

临界区其实就是操作共享数据的代码的部分。

- 一个程序运行多个线程本身是没有问题的
- 问题出在多个线程访问共享资源
  - 多个线程读共享资源其实也没有问题
  - 在多个线程对共享资源读写操作时发生指令交错，就会出现问题

- 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区

**竞态条件 Race Condition**：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件

## 2. synchronized解决方案

为了避免临界区的竞态条件发生，有多种手段可以达到目的。

- 阻塞式的解决方案：synchronized，Lock
- 非阻塞式的解决方案：原子变量

如果使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

### 2.1 synchronized对象锁

```java
Object obj = new Object();
synchronized(obj){
    //操作共享资源的代码
}
```

可以看到我们新建了一个Object对象，其实锁对象是可以为任意对象，但是只能有一个锁对象。

synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。

### 2.2 使用面向对象做改进

思想就是把需要保护的共享变量放入一个类。

```java
class Room {
    int value = 0;
    public void increment() {
        synchronized (this) {
            value++;
        }
    }
    public void decrement() {
        synchronized (this) {
            value--;
        }
    }
    public int get() {
        synchronized (this) {
            return value;
        }
    }
}
@Slf4j
public class Test1 {
    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(() -> {
            for (int j = 0; j < 5000; j++) {
                room.increment();
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int j = 0; j < 5000; j++) {
                room.decrement();
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("count: {}" , room.get());
    }
}

```

### 2.3 方法上的 synchronized

```java
class Test{
    public synchronized void test() {
    
    }
}
等价于
class Test{
    public void test() {
        synchronized(this) {
        
        }
    }
}
class Test{
    public synchronized static void test() {
    
    }
}
等价于
class Test{
    public static void test() {
        synchronized(Test.class) {
        
        }
    }
}
```

### 2.4 所谓的“线程八锁”

其实就是考察 synchronized 锁住的是哪个对象。

情况1：锁的都是Number的对象，或者说Number类中的this，输出12 或 21

```java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a() {
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
}

```



情况2：锁的都是Number的对象，或者说Number类中的this，1s后12，或 2 1s后 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
}
```



情况3：a和b方法锁的都是Number的对象，或者说Number类中的this，c方法没锁。

3 1s 12 或 23 1s 1 或 32 1s 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
    public void c() {
        log.debug("3");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
    new Thread(()->{ n1.c(); }).start();
}

```



情况4：锁的都是Number的对象，或者说Number类中的this，但是调用时候是不同的Number对象，因此相当于两把锁，锁并没有实质性的作用。没有互斥作用。2 1s 后 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    Number n2 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n2.b(); }).start();
}
```



情况5：a方法锁的是Number这个类，b方法锁的是Number的对象，或者说Number类中的this。

因此锁住的是不同的对象，所以相当于两把锁，锁并没有实质性作用。没有互斥作用。2 1s 后 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();//a方法锁的是类本身
    new Thread(()->{ n1.b(); }).start();//b方法锁的是Number的对象，或者说Number类中的this
}

```



情况6：锁的都是Number类本身，有互斥作用。1s 后12， 或 2 1s后 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public static synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n1.b(); }).start();
}
```



情况7：a方法锁的是Number这个类，b方法锁的是Number的对象，或者说Number类中的this。无互斥效果。2 1s 后 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public synchronized void b() {
        log.debug("2");
    }
  }
  public static void main(String[] args) {
      Number n1 = new Number();
      Number n2 = new Number();
      new Thread(()->{ n1.a(); }).start();
      new Thread(()->{ n2.b(); }).start();
}
```



情况8：锁的都是Number类本身，n1和n2都是属于Number类的，因此是同一个锁。有互斥作用。

1s 后12， 或 2 1s后 1

```java
@Slf4j(topic = "c.Number")
class Number{
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }
    public static synchronized void b() {
        log.debug("2");
    }
}
public static void main(String[] args) {
    Number n1 = new Number();
    Number n2 = new Number();
    new Thread(()->{ n1.a(); }).start();
    new Thread(()->{ n2.b(); }).start();
}

```

## 3. 变量的线程安全分析

**1、成员变量和静态变量是否线程安全？** 

- 如果它们没有被共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况
  - 如果只有读操作，则线程安全
  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全

**2、局部变量是否线程安全？** 

- 局部变量是线程安全的
- 但局部变量的引用稍有不同
  - 如果该对象没有逃离方法的作用范围，它是线程安全的
  - 如果该对象逃离方法的作用范围，需要考虑线程安全问题

### 3.1 局部变量线程安全分析

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_6.png)

### 3.2 局部变量的引用稍有不同

先看一个成员变量的例子：

```java
class ThreadUnsafe {
    ArrayList<String> list = new ArrayList<>();
    public void method1(int loopNumber) {
        for (int i = 0; i < loopNumber; i++) {
        // { 临界区, 会产生竞态条件
        method2();
        method3();
        // } 临界区
        }
    }
    private void method2() {
        list.add("1");
    }
    private void method3() {
        list.remove(0);
    }
}

```

执行

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
    ThreadUnsafe test = new ThreadUnsafe();
    for (int i = 0; i < THREAD_NUMBER; i++) {
        new Thread(() -> {
            test.method1(LOOP_NUMBER);
        }, "Thread" + i).start();
    }
}
```

其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：

```
Exception in thread "Thread1" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
at java.util.ArrayList.rangeCheck(ArrayList.java:657)
at java.util.ArrayList.remove(ArrayList.java:496)
...
```

分析：

- 无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量
- method3 与 method2 分析相同

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_7.png)

再将 list 修改为局部变量：

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();//方法局部变量，不再是类的成员变量了
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
```

那么就不会有上述问题了

分析：

- list 是局部变量，每个线程调用时会创建其不同实例，没有共享
- 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象
- method3 的参数分析与 method2 相同

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_8.png)

方法访问修饰符带来的思考：

如果把 method2 和 method3 的方法修改为 public 会不会出现线程安全问题？

- 情况1：有其它线程调用 method2 和 method3

情况1解析：其它线程调用的时候，不会出现线程安全问题，因为不涉及到共享，其他线程也会有自己的list传到方法中。

- 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    public void method2(ArrayList<String> list) {
        list.add("1");
    }
    public void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}

```

情况2解析：有可能会出现线程安全问题！因为ThreadSafeSubClass继承自ThreadSafe，又因为父类中的方法都是public的，所以子类是包含父类的成员方法的，并且方法上并没有final修饰符，所以子类不仅可以使用父类的方法而且可以重写并且覆盖。

上面代码中，子类重写了父类的method3方法，在method3中再次开启一个线程操作list集合，这个时候的list变量虽然是局部变量但是已经被子类和父类共享了，属于共享资源，因此可能会出现线程安全问题。

执行：

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
    ThreadSafeSubClass test = new ThreadSafeSubClass();
    for (int i = 0; i < THREAD_NUMBER; i++) {
        new Thread(() -> {
            test.method1(LOOP_NUMBER);
        }, "Thread" + i).start();
    }
}
//java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 会出错的
```

我们有代码可知，在每个线程任务中，ThreadSafeSubClass的对象调用method1方法，会找到父类的method1方法，这个时候method1方法中有一个list的局部变量，我们在method1方法中，又调用了method2和method3，此时，method2仍然完全是父类的方法，但是method3已经是子类重写之后的方法了，在重写的method3中，我们又开启了一个线程让list去remove(0)，此时我们知道这个list逃离了method1方法的作用范围，就需要考虑线程安全问题了。

> 从这个例子可以看出 private 或 ﬁnal 提供【安全】的意义所在，请体会开闭原则中的【闭】

### 3.3 常见线程安全类

- String
- Integer
- StringBuﬀer
- Random
- Vector
- Hashtable
- java.util.concurrent 包下的类

这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为

```java
Hashtable table = new Hashtable();

new Thread(()->{
    table.put("key", "value1");
}).start();

new Thread(()->{
    table.put("key", "value2");
}).start();
```

- 它们的每个方法是原子的
- 但注意它们多个方法的组合不是原子的，见后面分析

### 3.4 线程安全类方法的组合

分析下面代码是否线程安全？

```java
Hashtable table = new Hashtable();
// 比如线程1，线程2 并发的执行到下面
if( table.get("key") == null) {
    table.put("key", value);
}
```

很显然是线程不安全的。看代码逻辑，我们原本想要的是table的"key"为null时，将value放进去，不为null的时候不要放value，所以自始至终我们只想要一对key-value。但是上面代码可能会发生一种情况，就是：线程1来了发现table中key的值是null，想要将value放进去，但是还没等放进去，时间片用完了，CPU将时间片分给了线程2，线程2一看，诶发现table中key的值是null，将value放进去了，这是时间片轮到了线程1，线程1根据上下文切换的标记，继续前面的指令操作，将value放进去了，这时会将线程2放进去的value覆盖。整个流程下来，可以发现出现了线程安全问题。

思考一下：这种每个方法是原子的，但是两个方法组合就不是原子的了。为啥呢？

因为key是相同的，所以两个原子操作存在依赖关系，因此需要考虑线程安全问题。当下面的原子操作不依赖上面的原子操作的结果的话，就不用考虑两个原子操作合在一起的线程安全问题。

### 3.5 不可变类线程安全性

String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。

## 4. Monitor概念

更深入的学习synchronized 的底层。

### 4.1 Java对象头

以 32 位虚拟机为例

普通对象：

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_9.png)

数组对象：

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_10.png)

其中的Mark Word的结构为：

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_11.png)

64 位虚拟机 Mark Word：

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_12.png)

### 4.2 原理之Monitor（重量级锁）

Monitor被翻译为**监视器** 或者**管程** 

每个Java对象都可以关联一个Monitor对象，什么时候会关联呢？就是当我们使用synchronized(obj)尝试给对象上锁的时候，就会将java的对象与OS的Monitor关联。怎么关联的呢？靠一个指针关联，该对象头的Mark Word中就被设置一个指向Monitor对象的指针。

Monitor结构如下：synchronized对象锁（重量级锁）的底层原理

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_13.png)

解析：

- 刚开始的时候Monitor中的Owner为null
- 当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner。Owner表示谁是这把锁的主人，也就是所有者。
- 在Thread-2上锁的过程中，如果Thread-1，Thread-3，也来执行synchronized(obj)，就会进入EntryList中BLOCKED状态。
- Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争是非公平的
- 图中WaitSet中的Thread-0是之前获得过锁，但条件不满足，所以进入到WAITING状态的线程，在后面介绍wait-notify时会分析。

注意：

- synchronized必须是进入同一个对象的monitor才有上述的效果，不同线程争夺的锁对象必须是同一个对象，并且monitor只能有一个owner
- 不加synchronized的对象不会关联Monitor监视器，就不会做monitor的检查，也根本不会看对象的mark word，不遵从上述规则。

### 4.3 字节码之synchronized

```java
static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
    synchronized(lock) {
        counter++;
     }
}

```

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_14.png)

> 注意：上面的例子是同步代码块级别的，方法级别的synchronized不会在字节码指令中有所体现。

### 4.4 synchronized原理进阶

#### **4.4.1 轻量级锁** 

轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。

轻量级锁对使用者是透明的，即语法仍然是 synchronized，和正常加锁是一样的，其实，当一个线程中加锁默认先是轻量级锁，当有其它线程来抢同一把锁的时候，轻量级锁会发生锁膨胀，这时轻量级锁才会升级成重量级锁，也就是底层以Monitor来实现的。

案例：假设有两个方法同步块，利用同一个对象加锁

```java
static final Object obj = new Object();
public static void method1() {
     synchronized( obj ) {
         // 同步块 A
         method2();
     }
}
public static void method2() {
     synchronized( obj ) {
         // 同步块 B
     }
}
```

1. 每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，如果线程加了锁，每个线程的栈帧都会包含一个锁记录的结构，锁记录内部可以存储锁定对象的Mark Word和这个锁对象的引用地址reference。

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_15.png)

1. 让锁记录中 Object reference 指向锁对象，并尝试用 cas 方式来替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录中。

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_16.png)

1. 如果 cas 替换成功，对象头中存储了锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_17.png)

1. 如果 cas 失败，有两种情况：

1. 如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程

2. 如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_18.png)

1. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一，就是如下图这样的：

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_19.png)

1. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头

1. 成功，则解锁成功

2. 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，失败是因为此时锁对象头的位置会指向Monitor，所以进入重量级锁解锁流程

#### **4.4.2 锁膨胀** 

如果线程在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是已经有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

```java
static Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块
    }
}
```

- 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_20.png)

- 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程

- 即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址，Thread-0就是Monitor的Owner

- 然后Thread-1自己进入 Monitor 的 EntryList BLOCKED

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_21.png)

- 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程：即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程。

#### **4.4.3 自旋优化** 

重量级锁竞争的时候，还可以使用自旋来进行优化，就是当线程竞争锁，如果发现锁已经被占用，不会立刻进入到阻塞状态，会先自旋重试，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_22.png)

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_23.png)

- 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。
- 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。
- Java 7 之后不能控制是否开启自旋功能

#### **4.4.4 偏向锁** 

轻量级锁在没有竞争时（就自己这个线程），每次重入锁仍然需要执行 CAS 操作。

Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。

例如：

```java
static final Object obj = new Object();
public static void m1() {
    synchronized( obj ) {
        // 同步块 A
        m2();
    }
}
public static void m2() {
    synchronized( obj ) {
        // 同步块 B
        m3();
    }
}
public static void m3() {
    synchronized( obj ) {
        // 同步块 C
    }
}

```

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_24.png)

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_25.png)

>  **偏向状态：**

回忆一下对象头格式

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_26.png)

一个对象创建时：

1. 如果开启了偏向锁（默认是开启的），那么对象刚创建之后，markword 值为 0x05 即最后 3 位为 101，并且这时它的Thread，epoch，age都是0，在加锁的时候进行设置这些的值。
2. 偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-`XX:BiasedLockingStartupDelay=0`来禁用延迟
3. 注意：处于偏向锁的对象解锁后，线程 id 仍存储于锁对象的对象头中
4. 当偏向锁被禁用：添加 VM 参数`-XX:-UseBiasedLocking`禁用偏向锁，如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值，也就是说正常状态对象一开始是没有 hashCode 的，第一次调用才生成。
5. （markdown后三位：正常对象001，偏向锁对象101，轻量级锁对象000，重量级锁对象010）

>  撤销：

1、**撤销 - 调用对象 hashCode** 

观察上面的对象头表格，偏向锁的对象 MarkWord 中存储的是线程 id，没有hashcode值，因此如果调用 锁对象的hashCode 会导致偏向锁被撤销（禁用这个对象的偏向锁），变成正常对象，

- 轻量级锁会在锁记录中记录 hashCode。
- 重量级锁会在 Monitor 中记录 hashCode。

2、**撤销 - 其它线程使用对象** 

当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁。

**这里我提一嘴：只有一个线程，就是说我自己用同一对象来回加锁适合使用偏向锁。当多线程时，偏向锁不合适，多线程时就得视情况区分轻量级锁和重量级锁了。轻量级锁的场景：如果一个对象，虽然多个线程都要对它synchronized加锁，但是加锁的时间是错开的，也就是说虽然多个线程对同一对象加锁但是没有竞争的时候使用轻量级锁。当出现多个线程竞争同一把锁的时候，轻量级锁会膨胀升级成重量级锁。** 

有偏向锁时用偏向锁，有其它线程来用同一个对象上锁时，就撤销偏向锁，变为轻量级锁（此时就禁用偏向锁了），执行完同步代码块轻量级锁释放，锁对象变为正常对象。加轻量级锁有竞争发生时，就会发生锁膨胀，升级为重量级锁。

3、**撤销 - 调用 wait/notify** 

会使对象锁变成重量级锁，因为wait/notify方法只有重量级锁才支持

>  **批量重偏向：** 

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID。

当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至新的加锁线程。

>  **批量撤销：** 

当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。

## 5 wait notify

### 5.1 wait notify原理

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_27.png)

- Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态
- BLOCKED 和WAITING 的线程都处于阻塞状态，不占用 CPU 时间片
- BLOCKED 线程会在 Owner 线程释放锁时唤醒
- WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争

### 5.2 API介绍

- obj.wait() 让进入 object 监视器的线程到 waitSet 等待
- obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒
- obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒

它们都是线程之间进行协作通信的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法。

wait() 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止

wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify

## 6. wait notify 的正确姿势

### 6.1 sleep(long n) 和 wait(long n) 的区别

1. sleep 是 Thread 方法，而 wait 是 Object 的方法
2. sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用
3. **sleep 在睡眠时** ，如果在同步代码块中睡眠，虽然不占用CPU时间片，但是**不会释放对象锁的** ，其他线程要阻塞等锁被释放再抢锁，如果不在同步代码块里面睡，不占CPU时间片，其他线程就会抢夺时间片去执行。wait必须在synchronized中，并且 **wait 在等待的时候会释放对象锁** 。
4. 它们状态 TIMED_WAITING

注意：

notify 只能**随机**唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线 程，称之为【虚假唤醒】，就是说唤醒了错误的线程，人家等的条件还没达到就给唤醒了。

解决方案：改为 notifyAll，全给唤醒，全唤醒就是肯定对的符合条件线程也被唤醒了。

用 notifyAll 仅解决某个线程的唤醒问题，保证了对的线程被唤醒但是也同样把错的线程唤醒了，但使用 if + wait 判断仅有一次机会，一旦条件不成立，错的线程（也就是没等到条件达成的线程）就没有重新判断的机会了。

解决方法：用 while + wait，当条件不成立，再次 wait。

```java
package com.chan.concurrent.waitnotify;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;

@Slf4j(topic = "c.Step1")
public class Step1 {

    static boolean hasCigarette = false;
    static boolean hasWaiMai = false;
    static final Object room = new Object();

    public static void main(String[] args) throws InterruptedException {
        /**
         * 小南
         */
        Runnable task1 = () -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                while (!hasCigarette) {
                    log.debug("没烟，先歇会");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                log.debug("可以干活了");
            }
        };
        /**
         * 小女
         */
        Runnable task2 = () -> {
            synchronized (room) {
                log.debug("有外卖没?[{}]", hasWaiMai);
                while (!hasWaiMai){
                    log.debug("没外卖,先歇会");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有外卖没?[{}]", hasWaiMai);
                log.debug("可以干活了");
            }
        };
        /**
         * 送烟的
         */
        Runnable task3 = () -> {
            synchronized (room) {
                hasCigarette = true;
                log.debug("烟来了");
                room.notifyAll();
            }
        };
        /**
         * 送外卖的
         */
        Runnable task4 = () -> {
            synchronized (room) {
                hasWaiMai = true;
                log.debug("外卖来了");
                room.notifyAll();
            }
        };
        new Thread(task1, "小南").start();
        new Thread(task2, "小女").start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(task3, "送烟的").start();
        TimeUnit.SECONDS.sleep(2);
        new Thread(task4, "送外卖的").start();

    }


}

```

输出：

```
21:28:20 [小南] c.Step1 - 有烟没？[false]
21:28:20 [小南] c.Step1 - 没烟，先歇会
21:28:20 [小女] c.Step1 - 有外卖没?[false]
21:28:20 [小女] c.Step1 - 没外卖,先歇会
21:28:21 [送烟的] c.Step1 - 烟来了
21:28:21 [小女] c.Step1 - 没外卖,先歇会
21:28:21 [小南] c.Step1 - 有烟没？[true]
21:28:21 [小南] c.Step1 - 可以干活了
21:28:23 [送外卖的] c.Step1 - 外卖来了
21:28:23 [小女] c.Step1 - 有外卖没?[true]
21:28:23 [小女] c.Step1 - 可以干活了
```

固定套路：

```java
synchronized(lock) {
    while(条件不成立) {
        lock.wait();
    }
    // 干活
}
// 另一个线程
synchronized(lock) {
    // 让条件成立
    lock.notifyAll();
}
```

### 6.2 设计模式的同步模式之保护性暂停

即 Guarded Suspension，用在一个线程等待另一个线程的执行结果。

要点：

- 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject
- 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）
- JDK 中，join 的实现、Future 的实现，采用的就是此模式
- 因为要等待另一方的结果，因此归类到同步模式

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_28.png)

实现：

```java
package com.chan.concurrent.guardedSuspension;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class Downloader {
    public static List<String> download() throws IOException {
        HttpURLConnection connection = (HttpURLConnection) new URL("https://www.baidu.com").openConnection();
        List<String> lines = new ArrayList<>();
        InputStream in = connection.getInputStream();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null){
                lines.add(line);
            }
        }
        return lines;
    }
}


package com.chan.concurrent.guardedSuspension;

public class GuardedObject {
    private Object response;
    private final Object lock = new Object();

    /**
     * 产生结果
     */
    public void complete(Object response) {
        synchronized (lock) {
            this.response = response;
            lock.notifyAll();
        }
    }

    public Object get() {
        synchronized (lock) {
            while (response == null){
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }
}


package com.chan.concurrent.guardedSuspension;

import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.List;

@Slf4j(topic = "c.Test")
public class Test {
    // 线程1等待线程2的下载结果
    public static void main(String[] args) {
        GuardedObject guardedObject = new GuardedObject();

        Runnable task1 = new Runnable() {
            @Override
            public void run() {
                log.debug("等待结果");
                List<String> list = (List<String>) guardedObject.get();
                log.debug("结果的大小:{}", list);
            }
        };
        Runnable task2 = new Runnable() {
            @Override
            public void run() {
                try {
                    log.debug("执行下载");
                    List<String> list = Downloader.download();
                    guardedObject.complete(list);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };
        new Thread(task1, "t1").start();
        new Thread(task2, "t2").start();
    }
}

```

功能增强：增加等待超时机制。

分为三种情况：

1. 要么在等时范围内，这个线程被其他线程唤醒（等待的条件达成，不符合while条件了，不进入下次循环不用再wait了，在循环外直接进行唤醒之后要做的事）；
2. 要么在等时范围内，这个线程被其他线程唤醒（等待的条件未达成【虚假唤醒】，符合while条件，进入下次循环，继续wait）；
3. 要么超时还未被唤醒，到时间自己唤醒，然后判断不满足等待的条件，进到下次循环之后，判断没时间了直接break跳出循环。

```java
package com.chan.concurrent.guardedSuspension;

public class GuardedObject {
    private Object response;
    private final Object lock = new Object();

    /**
     * 产生结果
     */
    public void complete(Object response) {
        synchronized (lock) {
            this.response = response;
            lock.notifyAll();
        }
    }


    public Object get(long timeout) {
        synchronized (lock) {
            // 开始时间
            long begin = System.currentTimeMillis();
            // 经历的时间
            long passed = 0;
            while (response == null){
                // 这一轮循环剩余的可以等待的时间
                 long waitTime = timeout - passed;
                // 如果经历的时间超过了最大等待时间就退出循环
                if (waitTime <= 0) {
                    break;
                }
                try {
                    lock.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 求得经历时间
                passed = System.currentTimeMillis() - begin;
            }
            return response;
        }
    }
}

package com.chan.concurrent.guardedSuspension;

import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.List;

@Slf4j(topic = "c.Test")
public class Test {
    // 线程1等待线程2的下载结果
    public static void main(String[] args) {
        GuardedObject guardedObject = new GuardedObject();

        Runnable task1 = new Runnable() {
            @Override
            public void run() {
                log.debug("等待结果");
                List<String> list = (List<String>) guardedObject.get(3000);
                log.debug("结果的大小:{}", list);
            }
        };
        Runnable task2 = new Runnable() {
            @Override
            public void run() {
                try {
                    log.debug("执行下载");
                    List<String> list = Downloader.download();
                    guardedObject.complete(list);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };
        new Thread(task1, "t1").start();
        new Thread(task2, "t2").start();
    }
}


```

### 6.3 多任务版 GuardedObject

上一个例子是单任务版的GuardedObject案例，一个下载任务，结果（本案例就是下载的资源）提取到GuardedObject，两个线程一个设置结果，一个获得结果，一个线程等另一个线程完善的结果，这种就是同步模式之保护性暂停。

案例：

图中 Futures 就好比居民楼一层的蜂巢（GO对象就是蜂巢的每个快递箱，response就是快递，id用来标识Guarded Object），左侧的 t0，t2，t4 就好比等待快递的居民，右侧的 t1，t3，t5 就好比快递小哥。

在这个多版本的案例中，“结果”是多个，就是每对儿快递员和居民都有一个“结果”就是快递包裹，这样如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_29.png)

代码：

新增 id 用来标识 Guarded Object

```java
package com.chan.concurrent.guardedSuspensionManyTask;

public class GuardedObject {

    //结果
    private Object response;

    //编号 标识guardedObject
    private Integer id;

    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }

    /**
     * 获取结果,居民取快递
     * @param timeout 时间
     * @return 结果(快递)
     */
    public Object getFastMail (long timeout){
        synchronized (this) {
            //开始时间
            long beginTime = System.currentTimeMillis();
            //过去的时间
            long passedTime = 0;
            while (response == null) {
                if (passedTime >= timeout) {
                    break;
                }
                try {
                    //没有结果,等待
                    this.wait(timeout - passedTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                passedTime = System.currentTimeMillis() - beginTime;
            }
            return response;
        }
    }

    /**
     * 设置结果,快递员将快递按编号放入蜂巢的某个快递箱
     * @param response 结果(快递)
     */
    public void setFastMail (Object response){
        synchronized (this) {
            //设置结果
            this.response = response;
            //唤醒
            this.notifyAll();
        }
    }

}

```

中间解耦类

```java
package com.chan.concurrent.guardedSuspensionManyTask;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 快递柜(蜂巢) 中间解耦类
 */
public class FastMailBox {

    //编号 标识guardedObject
    private static int id = 1;

    //蜂巢的多个快递箱
    private static final Map<Integer, GuardedObject> boxes = new ConcurrentHashMap<>();

    /**
     * 产生唯一id
     * @return 编号
     */
    public static synchronized int generateId() {
        return id++;
    }


    /**
     * 创建快递,放入快递柜,返回快递
     *
     * @return GuardedObject
     */
    public static GuardedObject createGuardedObject() {
        GuardedObject guardedObject = new GuardedObject();
        guardedObject.setId(generateId());
        boxes.put(guardedObject.getId(), guardedObject);
        return guardedObject;
    }

    /**
     * 得到所有编号
     *
     * @return 编号集合
     */
    public static Set<Integer> getIds() {
        return boxes.keySet();
    }

    /**
     * 快递员揽件,揽件之后删除,因为都是静态的,属于类的,不删除的话,会伴随类一直不会被回收会占用内存
     *
     * @return GuardedObject
     */
    public static GuardedObject getGuardedObject(int id) {
        return boxes.remove(id);
    }

}

```

业务相关类

```java
package com.chan.concurrent.guardedSuspensionManyTask;

import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "c.People")
public class People implements Runnable {
    @Override
    public void run() {
        //买快递
        GuardedObject guardedObject = FastMailBox.createGuardedObject();
        log.debug("准备取快递,快递编号id: {}", guardedObject.getId());
        Object fastMail = guardedObject.getFastMail(5000);
        log.debug("收到快递啦,快速编号id: {}, 快递: {}", guardedObject.getId(), fastMail);
    }
}

package com.chan.concurrent.guardedSuspensionManyTask;

import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "c.Postman")
public class Postman implements Runnable {
    //送快递的一定知道快递和编号
    private final int id;
    private final String fastMail;

    public Postman(int id, String fastMail) {
        this.id = id;
        this.fastMail = fastMail;
    }

    @Override
    public void run() {
        GuardedObject guardedObject = FastMailBox.getGuardedObject(id);
        log.debug("送快递 快递编号id: {}, 快递: {}", id, fastMail);
        guardedObject.setFastMail(fastMail);
    }
}

```

测试

```java
package com.chan.concurrent.guardedSuspensionManyTask;

import java.util.concurrent.TimeUnit;

public class Test {
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 3; i++) {
            new Thread(new People(), "居民" + i).start();
        }
        TimeUnit.SECONDS.sleep(2);
        for (Integer id : FastMailBox.getIds()) {
            new Thread(new Postman(id, "快递" + id), "快递员" + id).start();
        }
    }
}

```

某次运行结果

```
22:32:51 [居民2] c.People - 准备取快递,快递编号id: 3
22:32:51 [居民0] c.People - 准备取快递,快递编号id: 1
22:32:51 [居民1] c.People - 准备取快递,快递编号id: 2
22:32:53 [快递员1] c.Postman - 送快递 快递编号id: 1, 快递: 快递1
22:32:53 [快递员2] c.Postman - 送快递 快递编号id: 2, 快递: 快递2
22:32:53 [居民0] c.People - 收到快递啦,快速编号id: 1, 快递: 快递1
22:32:53 [居民1] c.People - 收到快递啦,快速编号id: 2, 快递: 快递2
22:32:53 [快递员3] c.Postman - 送快递 快递编号id: 3, 快递: 快递3
22:32:53 [居民2] c.People - 收到快递啦,快速编号id: 3, 快递: 快递3
```

### 6.4 设计模式之生产者消费者

定义：

- 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应
- 消费队列可以用来平衡生产和消费的线程资源
- 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据
- 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据
- JDK 中各种阻塞队列，采用的就是这种模式
- 我们使用的消息中间件MQ什么的，也是消费者生产者模式的思想是一致的。但是MQ属于进程间通信，这块是线程间通信。

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_30.png)

实现案例：

消息：

注：想要类中的属性不可变，只提供相应的构造函数和get方法即可，保险点属性再加上final和private。

```java
package com.chan.concurrent.producercustomer;

public class Message {
    //由于涉及到并发,因此都是不可变属性,使用private,final修饰,不提供set方法
    //只在构造里面提供设置属性的功能,对象一旦创建内容就不可再改变
    private final int id;
    private final Object message;

    public Message(int id, Object message) {
        this.id = id;
        this.message = message;
    }

    public int getId() {
        return id;
    }

    public Object getMessage() {
        return message;
    }
}


```

消息队列：

```java
package com.chan.concurrent.producercustomer;
import lombok.extern.slf4j.Slf4j;

import java.util.LinkedList;
@Slf4j(topic = "c.MessageQueue")
public class MessageQueue {

    //消息队列,消息先进先出,使用双向链表作为容器
    private final LinkedList<Message> queue;

    //消息队列容量
    private final int capacity;

    /**
     * 构造函数,将消息队列的大小设置成活的,有调用者指定消息队列的大小
     * 创建对象时再初始化queue,在构造函数中初始化等价于在成员位置new
     * @param capacity 消息队列容量
     */
    public MessageQueue(int capacity) {
        this.capacity = capacity;
        queue = new LinkedList<>();
    }

    /**
     * 在消息队列中取 消息
     * @return 消息对象
     */
    public Object getMessage() {
        synchronized (queue) {
            while (queue.isEmpty()) {
                try {
                    log.debug("消息队列为空...wait, plz...");
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //遵循先进先出,从头拿,返回,被消费之后消息就删了
            Message message = queue.removeFirst();
            //唤醒,消息队列又有剩余空间了
            queue.notifyAll();
            return message;
        }
    }

    /**
     * 向消息队列中放 消息
     * @param message 消息对象
     */
    public void putMessage(Message message) {
        synchronized (queue) {
            while (queue.size() == capacity) {
                try {
                    log.debug("消息队列容量已达上限: {} wait, plz...", capacity);
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //后进后出,加在尾部
            queue.addLast(message);
            //唤醒,消息队列又有新消息了
            queue.notifyAll();
        }
    }
}

```

测试：

```java
package com.chan.concurrent.producercustomer;

import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.List;
@Slf4j(topic = "c.Test")
public class Test {
    public static void main(String[] args) {

        MessageQueue messageQueue = new MessageQueue(3);
        
        //4 个生产者线程, 下载任务,下载之后放入队列
        for (int i = 0; i < 4; i++) {
            int id = i;
            new Thread(() -> {
                try {
                    log.debug("download...");
                    List<String> download = Downloader.download();
                    Message message = new Message(id, download);
                    log.debug("try putting message {}", id);
                    messageQueue.putMessage(message);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }, "生产者" + i).start();
        }

        // 1 个消费者线程, 处理结果
        new Thread(() -> {
            while (true) {
                Message message = (Message) messageQueue.getMessage();
                List<String> response = (List<String>) message.getMessage();
                log.debug("get message id({}): 一共[{}]lines", message.getId(), response.size());
            }
        }, "消费者").start();
    }
}

```

下载工具类：

```java
package com.chan.concurrent.producercustomer;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class Downloader {
    public static List<String> download() throws IOException {
        HttpURLConnection connection = (HttpURLConnection) new URL("https://www.baidu.com").openConnection();
        List<String> lines = new ArrayList<>();
        InputStream in = connection.getInputStream();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null){
                lines.add(line);
            }
        }
        return lines;
    }
}

```

结果：

```
18:22:01 [生产者2] c.Test - download...
18:22:01 [消费者] c.MessageQueue - 消息队列为空...wait, plz...
18:22:01 [生产者0] c.Test - download...
18:22:01 [生产者3] c.Test - download...
18:22:01 [生产者1] c.Test - download...
18:22:03 [生产者0] c.Test - try putting message 0
18:22:03 [生产者1] c.Test - try putting message 1
18:22:03 [消费者] c.Test - get message id(0): 一共[3]lines
18:22:03 [生产者2] c.Test - try putting message 2
18:22:03 [生产者3] c.Test - try putting message 3
18:22:03 [消费者] c.Test - get message id(1): 一共[3]lines
18:22:03 [消费者] c.Test - get message id(2): 一共[3]lines
18:22:03 [消费者] c.Test - get message id(3): 一共[3]lines
18:22:03 [消费者] c.MessageQueue - 消息队列为空...wait, plz...
```

## 7. Park & Unpark

### 7.1 基本使用

它们是LockSupport类中的方法

```java
// 暂停当前线程
LockSupport.park();

// 恢复某个线程的运行
LockSupport.unpark(暂停的线程对象);
```

先park再unpark

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(1);
    log.debug("park...");
    LockSupport.park();//暂停
    log.debug("resume...");
},"t1");
t1.start();

sleep(2);
log.debug("unpark...");
LockSupport.unpark(t1);//在main线程中唤醒暂停的t1
```

输出:

```
18:42:52.585 c.TestParkUnpark [t1] - start...
18:42:53.589 c.TestParkUnpark [t1] - park...
18:42:54.583 c.TestParkUnpark [main] - unpark...
18:42:54.583 c.TestParkUnpark [t1] - resume...
```

先 unpark 再 park

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(2);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
}, "t1");
t1.start();

sleep(1);
log.debug("unpark...");
LockSupport.unpark(t1);
```

输出:

```
18:43:50.765 c.TestParkUnpark [t1] - start...
18:43:51.764 c.TestParkUnpark [main] - unpark...
18:43:52.769 c.TestParkUnpark [t1] - park...
18:43:52.769 c.TestParkUnpark [t1] - resume...
```

### 7.2 特点

与 Object 的 wait & notify 相比

- wait，notify 和 notifyAll 必须配合 Object Monitor (重量级锁) 一起使用，而 park，unpark 不必
- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】
- park & unpark 可以先 unpark，而 wait & notify 不能先 notify

> unpark既可以在park之前用也可以在park之后用, 都可以将对应的park线程unpark.

## 8. 重新深入理解线程状态转换

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_31.png)

假设有线程Thread t

### 情况1 NEW—>RUNNABLE

- 当调用 t.start() 方法时，由 NEW --> RUNNABLE, 这个时候不一定就直接RUNNING了, 有可能先READY状态, 主要取决于CPU的时间片, 抢占式调度.  图中的可运行状态就是READY. READY和RUNNING和OS层面的BLOCKED都属于RUNNABLE.

### 情况2  RUNNABLE <--> WAITING

t 线程用 synchronized(obj) 获取了对象锁后

- 调用 obj.wait() 方法时，t 线程从 RUNNABLE --> WAITING
- 调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时:
  - 竞争锁成功，t 线程从 WAITING --> RUNNABLE
  - 竞争锁失败，t 线程从 WAITING --> BLOCKED

```java
public class TestWaitNotify {
    final static Object obj = new Object();
    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行....");
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...."); // 断点
            }
        },"t1").start();
        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行....");
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...."); // 断点
            }
        },"t2").start();
        sleep(0.5);
        log.debug("唤醒 obj 上其它线程");
        synchronized (obj) {
            obj.notifyAll(); // 唤醒obj上所有等待线程断点
        }
    }
}

```

### 情况3 RUNNABLE <--> WAITING

- **当前线程** 调用 t.join() 方法时，当前线程从 RUNNABLE --> WAITING
  - 注意是**当前线程** 在**t 线程对象** 的监视器上等待

- **t 线程** 运行结束，或调用了**当前线程** 的 interrupt() 时，**当前线程** 从 WAITING --> RUNNABLE

### 情况4 RUNNABLE <--> WAITING

- 当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE --> WAITING
- 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING -->RUNNABLE, 直接回到RUNNABLE状态, 不用像wait()那样重新竞争锁.

### 情况5 RUNNABLE <--> TIMED_WAITING

t 线程用 synchronized(obj) 获取了对象锁后

- 调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --> TIMED_WAITING
- t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时
  - 竞争锁成功，t 线程从 TIMED_WAITING --> RUNNABLE
  - 竞争锁失败，t 线程从 TIMED_WAITING --> BLOCKED

### 情况6 RUNNABLE <--> TIMED_WAITING

- **当前线程** 调用 t.join(long n) 方法时，**当前线程** 从 RUNNABLE --> TIMED_WAITING
  - 注意是**当前线程** 在**t 线程对象** 的监视器上等待

- **当前线程** 等待时间超过了 n 毫秒，或**t 线程** 运行结束，或调用了**当前线程** 的 interrupt() 时，**当前线程** 从TIMED_WAITING --> RUNNABLE

### 情况7 RUNNABLE <--> TIMED_WAITING

- 当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING
- 当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING --> RUNNABLE, 这里是直接回到RUNNABLE状态, 不用像wait()那样重新竞争锁.

### 情况8 RUNNABLE <--> TIMED_WAITING

- 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE --> TIMED_WAITING
- 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从TIMED_WAITING--> RUNNABLE, 这里是直接回到RUNNABLE状态, 不用像wait()那样重新竞争锁.

### 情况9 RUNNABLE <--> BLOCKED

- t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE --> BLOCKED
- 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED --> RUNNABLE ，其它失败的线程仍然 BLOCKED

### 情况10 RUNNABLE <--> TERMINATED

当前线程所有代码运行完毕，进入 TERMINATED

## 9. 多把锁

我们知道，当多个线程操作共享资源的时候，为了防止线程同步问题，我们使用一把锁来保证不会发生线程安全问题。

当业务资源无相关的时候，也就是说互不相干，这个时候，我们就会使用两把锁了，因为这样可以细分锁粒度，增加并发度。

但是如果一个线程需要同时获得多把锁的时候，这个时候就容易发生死锁。

将锁的粒度细分：

- 好处，是可以增强并发度
- 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁

### 9.1 定位死锁

使用jstack工具，JDK自带的工具。

https://www.cnblogs.com/chenpi/p/5377445.html

```
chanservy@ChanServy:~/idea/projects/concurrent$ jps #列出每个线程id
chanservy@ChanServy:~/idea/projects/concurrent$ jstack 17256 #查看对应的
```

## 10. 活跃性

### 10.1 死锁

死锁是由于2个线程互相持有对方想要的锁，导致谁都无法继续向下运行，2个线程都阻塞住了，2个线程都结束不了。

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_32.png)

一个线程需要同时获取多把锁，这时就容易发生死锁。

t1 线程获得 A 对象锁，接下来想获取 B 对象的锁，t2 线程获得 B 对象锁，接下来想获取 A对象的锁，例：

```java
public static void main(String[] args) {
    Object A = new Object();
    Object B = new Object();
    Thread t1 = new Thread(() -> {
        synchronized (A) {
            log.debug("lock A");
            sleep(1);
            synchronized (B) {
                log.debug("lock B");
                log.debug("操作...");
            }
        }
    }, "t1");
    Thread t2 = new Thread(() -> {
        synchronized (B) {
            log.debug("lock B");
            sleep(0.5);
            synchronized (A) {
                log.debug("lock A");
                log.debug("操作...");
            }
        }
    }, "t2");
    t1.start();
    t2.start();
}

```

结果:

```
12:22:06.962 [t2] c.TestDeadLock - lock B
12:22:06.962 [t1] c.TestDeadLock - lock A
```

- 避免死锁要注意加锁顺序
- 另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查。

上面的案例中，两个线程的加锁顺序不同，线程t1先获得A锁再嵌套获得B锁，线程t2反之，这样造成了死锁问题。

解决方案：2个线程用相同的顺序加锁，这样就可以避免死锁问题，顺序加锁的解决方案：

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_33.png)

但是又可能迎来了新的问题：饥饿

### 10.2 饥饿

饥饿：没有死锁，大家都没有相互占有对应所需的资源，但是有的线程得到锁的机会太少了，都被其它线程抢去了，导致它得不到执行，从而饥饿。

### 10.3 活锁

活锁：2个线程无阻塞，都在使用CPU不断的向下运行，但是由于改变了对方的结束条件，导致2个线程都结束不了。这种现象就是活锁。

解决方案：让2个线程的执行时间有一定的交错，在线程执行任务时增加随机的睡眠时间。

### 10.4 哲学家就餐问题

![img](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_34.png)

有五位哲学家，围坐在圆桌旁。

- 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。
- 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。
- 如果筷子被身边的人拿着，自己就得等待

```java
// 筷子类
class Chopstick {
    String name;
    public Chopstick(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}

//哲学家类
class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(1);
    }

    @Override
    public void run() {
        while (true) {
            // 获得左手筷子
            synchronized (left) {
                // 获得右手筷子
                synchronized (right) {
                    // 吃饭
                    eat();
                }
                // 放下右手筷子
            }
            // 放下左手筷子
        }
    }
}

public class Test {
    public static void main(){
        Chopstick c1 = new Chopstick("1");
        Chopstick c2 = new Chopstick("2");
        Chopstick c3 = new Chopstick("3");
        Chopstick c4 = new Chopstick("4");
        Chopstick c5 = new Chopstick("5");
        new Philosopher("苏格拉底", c1, c2).start();
        new Philosopher("柏拉图", c2, c3).start();
        new Philosopher("亚里士多德", c3, c4).start();
        new Philosopher("赫拉克利特", c4, c5).start();
        new Philosopher("阿基米德", c5, c1).start();
    }
}
```

## 11. ReentrantLock

前面线程活跃性提到的：死锁；饥饿；活锁，其中除了活锁用2个线程的执行时间交错开来解决之外，其它的现象都可以使用ReentrantLock来解决。

ReentrantLock：可重入锁，JUC下面的类。

相对于 synchronized 它具备如下特点：

- 可中断：尝试获得锁，可被打断。防死锁，被动。
- 可以设置超时时间：规定时间内如果获取不到锁，那我就放弃争抢锁了。防死锁，主动。
- 可以设置为公平锁：不会像之前那样不按顺序争抢锁了，而是先到先得。防饥饿。（ReentrantLock 默认是不公平的）
- 支持多个条件变量：比如可以有多个WaitSet，“不同种类的等待室”，可细分。

与 synchronized 一样，都支持可重入

基本语法：

```java
// 获取锁
reentrantLock.lock();//放在try里面也行 没区别
try {
    // 临界区
} finally {
    // 释放锁
    reentrantLock.unlock();
}
/************************************************************************************重要*/
//1
Object obj = new Object();
//obj就是锁对象, 真正的锁是这个锁对象关联的Monitor
synchronized(obj) {
    //同步代码
}
//2
ReentrantLock lock = new ReentrantLock();
// lock就是锁对象, 这个对象取代了之前的 obj+Monitor 了
lock.lock();
```

### 11.1 可重入

可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁。

如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。

```java
static ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        method1();
    }
    public static void method1() {
        lock.lock();
        try {
            log.debug("execute method1");
            method2();
        } finally {
            lock.unlock();
        }
    }
    public static void method2() {
        lock.lock();
        try {
            log.debug("execute method2");
            method3();
        } finally {
            lock.unlock();
        }
    }
    public static void method3() {
        lock.lock();
        try {
            log.debug("execute method3");
        } finally {
            lock.unlock();
        }
    }
17:59:11.862 [main] c.TestReentrant - execute method1
17:59:11.865 [main] c.TestReentrant - execute method2
17:59:11.865 [main] c.TestReentrant - execute method3
```

### 11.2 可打断

解释：一个线程在等待锁的过程中，其它线程可用interrupt() 方法终止它的等待，（尝试获得锁，可被打断）

实现：synchronized和lock()都不可被打断，但是使用一个方法实现：lockInterruptibly()方法。

- 如果没竞争，那么lockInterruptibly()此方法就会获取lock对象锁。
- 如果有竞争，进入了阻塞队列的话，可被其它线程使用interrupt打断，就不要继续等待锁了，不用死等，有效避免了死锁的发生，但是这种方式是被动的，因为是靠其它线程打断的。另外，如果被打断，没获取到锁，那就不会继续向下运行了。lockInterruptibly()方法会要求捕获一个异常，在catch中直接return。

实例:

```java
        ReentrantLock lock = new ReentrantLock();
        Thread t1 = new Thread(() -> {
            log.debug("启动...");
            try {
                lock.lockInterruptibly();
            } catch (InterruptedException e) {
                e.printStackTrace();
                log.debug("等锁的过程中被打断");
                return;
            }
            try {
                log.debug("获得了锁");
            } finally {
                lock.unlock();
            }
        }, "t1");
        lock.lock();
        log.debug("获得了锁");
        t1.start();
        try {
            sleep(1);
            t1.interrupt();
            log.debug("执行打断");
        } finally {
            lock.unlock();
        }

       //输出
18:02:40.520 [main] c.TestInterrupt - 获得了锁
18:02:40.524 [t1] c.TestInterrupt - 启动...
18:02:41.530 [main] c.TestInterrupt - 执行打断
java.lang.InterruptedException
at
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)
at
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)
at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)
at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17)
at java.lang.Thread.run(Thread.java:748)
18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断
```

注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断。

```java
        ReentrantLock lock = new ReentrantLock();
        Thread t1 = new Thread(() -> {
            log.debug("启动...");
            lock.lock();
            try {
                log.debug("获得了锁");
            } finally {
                lock.unlock();
            }
        }, "t1");
        lock.lock();
        log.debug("获得了锁");
        t1.start();
        try {
            sleep(1);
            t1.interrupt();
            log.debug("执行打断");
        } finally {
            lock.unlock();
        }

       //输出
18:06:56.261 [main] c.TestInterrupt - 获得了锁
18:06:56.265 [t1] c.TestInterrupt - 启动...
18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁
18:06:58.267 [main] c.TestInterrupt - 释放了锁
18:06:58.267 [t1] c.TestInterrupt - 获得了锁 
```

### 11.3 锁超时

尝试去获取锁时，等待的超时时间，防止一直等待的情况，避免死锁。这个方式是主动的，因为是自己设置的超时时间，在设定的时间内拿到锁那就继续执行，到了设定时间依然没拿到锁的话直接放弃获取锁，不会无限等待。

- boolean tryLock() 返回布尔值；空参数：立刻返回结果，不会等待。
  - true：代表获取到了锁，就是已经获取到了lock锁对象，并且返回true
  - false：获取不到锁。不再向下运行，直接return。

```java
      ReentrantLock lock = new ReentrantLock();
      Thread t1 = new Thread(() -> {
          log.debug("启动...");
          if (!lock.tryLock()) {
              log.debug("获取立刻失败，返回");
              return;
          }
          try {
              log.debug("获得了锁");
          } finally {
              lock.unlock();
          }
      }, "t1");
      lock.lock();
      log.debug("获得了锁");
      t1.start();
      try {
          sleep(2);
      } finally {
          lock.unlock();
      }

//输出
18:15:02.918 [main] c.TestTimeout - 获得了锁
18:15:02.921 [t1] c.TestTimeout - 启动...
18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回

```

- boolean tryLock(long timeout, TimeUnit unit) 返回布尔值；有参数：在设定的时间内拿到锁返回true继续执行，到了设定时间依然没拿到锁返回false放弃获取锁。
  - true：代表在设定时间内获取到了锁，就是已经获取到了lock锁对象，并且返回true
  - false：设定时间内获取不到锁。（主动打断）不再向下运行，直接return。在if逻辑中return一次，在捕获打断异常的catch中再return一次。

```java
        ReentrantLock lock = new ReentrantLock();
        Thread t1 = new Thread(() -> {
            log.debug("启动...");
            try {
                if (!lock.tryLock(1, TimeUnit.SECONDS)) {
                    log.debug("获取等待 1s 后失败，返回");
                    return;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
                return;
            }
            try {
                log.debug("获得了锁");
            } finally {
                lock.unlock();
            }
        }, "t1");
        lock.lock();
        log.debug("获得了锁");
        t1.start();
        try {
            sleep(2);
        } finally {
            lock.unlock();
        }

// 输出
18:19:40.537 [main] c.TestTimeout - 获得了锁
18:19:40.544 [t1] c.TestTimeout - 启动...
18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回 
```

所以由于synchronized的嵌套并且锁对象不同时，容易产生的死锁问题，可通过ReentrantLock来解决。

使用 tryLock 解决哲学家就餐问题

```java
class Chopstick extends ReentrantLock {
     String name;
     public Chopstick(String name) {
         this.name = name;
     }
     @Override
     public String toString() {
         return "筷子{" + name + '}';
     }
}

class Philosopher extends Thread {
    Chopstick left;
    Chopstick right;
    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }
    @Override
    public void run() {
        while (true) {
            // 尝试获得左手筷子
            if (left.tryLock()) {
                try {
                    // 尝试获得右手筷子
                    if (right.tryLock()) {
                        try {
                            eat();
                        } finally {
                            right.unlock();
                        }
                    }
                } finally {
                    left.unlock();
                }
            }
        }
    }
    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(1);
    }
}

```

### 11.4 公平锁

ReentrantLock默认是不公平的，synchronized也是不公平的，都是抢占的获取锁，不按照先来后到的。

在ReentrantLock中可以设置为公平的，先到先得，获取锁。 

改为公平锁：

```java
ReentrantLock lock = new ReentrantLock(true);
```

公平锁的本意是解决饥饿问题, 但是没必要, 公平锁一般不用设置，会降低并发度, 影响性能.

### 11.5 条件变量

synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待。

ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比：

- synchronized 是那些不满足条件的线程都在一间休息室等消息
- 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒。

使用要点：

- await 前需要获得锁
- await 执行后，会释放锁，进入 conditionObject 等待
- await 的线程被唤醒signal(), signalAll()（或打断interrupt、或超时）去重新竞争 lock 锁
- 竞争 lock 锁成功后，从 await 后继续执行

```java
package com.chan.concurrent.condition;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
@Slf4j(topic = "c.Test")
public class Test {

    static ReentrantLock lock = new ReentrantLock();
    static Condition waitCigaretteQueue = lock.newCondition();
    static Condition waitTakeoutQueue = lock.newCondition();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) throws InterruptedException {

        new Thread(() -> {
            lock.lock();
            try {
                while (!hasCigarette) {
                    log.debug("没有烟,先歇着...");
                    waitCigaretteQueue.await();
                }
                log.debug("烟来了,开始工作了...");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "小南").start();

        new Thread(() -> {
            lock.lock();
            try {
                while (!hasTakeout) {
                    log.debug("没有外卖,先歇着...");
                    waitTakeoutQueue.await();
                }
                log.debug("外卖到了,开始工作...");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "小女").start();

        TimeUnit.SECONDS.sleep(2);
        lock.lock();
        try {
            log.debug("烟来了...");
            hasCigarette = true;
            waitCigaretteQueue.signal();
        } finally {
            lock.unlock();
        }

        TimeUnit.SECONDS.sleep(2);
        lock.lock();
        try {
            log.debug("外卖来了...");
            hasTakeout = true;
            waitTakeoutQueue.signal();
        } finally {
            lock.unlock();
        }
    }
}

```

### 11.6 同步模式之顺序控制

#### 11.6.1 固定运行顺序

比如，必须先 2 后 1 打印

**wait notify 版**

```java
package com.chan.concurrent.controlOrder;

import lombok.extern.slf4j.Slf4j;

/**
 * 先打印2后打印1
 */
@Slf4j(topic = "c.Test")
public class Test {
    static final Object obj = new Object();
    static volatile boolean t2Run = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (obj) {
                while (!t2Run) {
                    try {
                        log.debug("线程2还没执行,我得等着...");
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("轮到我输出1啦...");
                System.out.println(1);
            }
        }, "t1").start();

        new Thread(() -> {
            synchronized (obj) {
                log.debug("我先输出2...");
                System.out.println(2);
                t2Run = true;
                obj.notifyAll();
            }
        }, "t2").start();
    }
}

```

**Park Unpark 版**

```java
package com.chan.concurrent.controlOrder;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.locks.LockSupport;

/**
 * 先输出2后输出1
 */
@Slf4j(topic = "c.Test3")
public class Test3 {

    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                LockSupport.park();
                System.out.println(1);
            }
        },"t1");
        t1.start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(2);
                LockSupport.unpark(t1);
            }
        },"t2").start();
    }
}

```

**ReentrantLock 版**

```java
package com.chan.concurrent.controlOrder;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
/**
 * 先打印2后打印1
 */
@Slf4j(topic = "c.Test2")
public class Test2 {
    static ReentrantLock lock = new ReentrantLock();
    static Condition condition = lock.newCondition();
    static volatile boolean t2HasRun = false;

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                try {
                    while (!t2HasRun) {
                        log.debug("没输出2,先等待...");
                        condition.await();
                    }
                    log.debug("2输出了,我现在输出1...");
                    System.out.println(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        },"t1").start();


        new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                try {
                    log.debug("输出2...");
                    System.out.println(2);
                    t2HasRun = true;
                    condition.signal();
                }finally {
                    lock.unlock();
                }
            }
        },"t2").start();
    }

}

```

#### 11.6.2 交替输出

线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现

**wait notify 版**

```java
package com.chan.concurrent.jiaotishuchu;

/**
 * 线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现
 * 思路: 在类通过构造初始化的时候带一个值(1,2,3随便),然后这个值代表线程的编号;
 * 每个线程运行的时候,如果初始化的值对应自己编号的值那么就输出并且将flag改为自己线程编号值的下一个值,对应不上就等待;
 * 1-->2; 2-->3; 3-->1
 */
public class AlternatePrint1 {
    public static void main(String[] args) {
        SyncWaitNotifyAll syncWaitNotifyAll = new SyncWaitNotifyAll(1, 5);
        new Thread(() -> syncWaitNotifyAll.print(1, 2, "a")).start();
        new Thread(() -> syncWaitNotifyAll.print(2, 3, "b")).start();
        new Thread(() -> syncWaitNotifyAll.print(3, 1, "c")).start();
    }
}

/**
 * 交替输出
 */
class SyncWaitNotifyAll {
    //线程编号
    private int flag;
    //每个字母一共输出几次
    private final int total;

    public SyncWaitNotifyAll(int flag, int total) {
        this.flag = flag;
        this.total = total;
    }

    public void print(int waitFlag, int nextFlag, String str) {
        for (int i = 0; i < total; i++) {
            synchronized (this) {
                while (this.flag != waitFlag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                flag = nextFlag;
                this.notifyAll();
            }
        }
    }
}


```

**Lock 条件变量版**

```java
package com.chan.concurrent.jiaotishuchu;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class AlternatePrint2 {
    public static void main(String[] args) {
        SyncAwaitSignal syncAwaitSignal = new SyncAwaitSignal(5);
        Condition waitSet1 = syncAwaitSignal.newCondition();
        Condition waitSet2 = syncAwaitSignal.newCondition();
        Condition waitSet3 = syncAwaitSignal.newCondition();
        new Thread(() -> syncAwaitSignal.printer(waitSet1, waitSet2, "a")).start();
        new Thread(() -> syncAwaitSignal.printer(waitSet2, waitSet3, "b")).start();
        new Thread(() -> syncAwaitSignal.printer(waitSet3, waitSet1, "c")).start();
        syncAwaitSignal.start(waitSet1);
    }
}

class SyncAwaitSignal extends ReentrantLock {
    private final int total;

    public SyncAwaitSignal(int total) {
        this.total = total;
    }


    public void start(Condition current) {
        lock();
        try {
            current.signal();
        } finally {
            unlock();
        }
    }
    public void printer(Condition current, Condition next, String str) {
        for (int i = 0; i < total; i++) {
            lock();
            try {
                current.await();
                System.out.print(str);
                next.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                unlock();
            }
        }
    }
}

```

**Park Unpark 版**

```java
package com.chan.concurrent.jiaotishuchu;

import java.util.concurrent.locks.LockSupport;

public class AlternatePrint3 {
    public static void main(String[] args) {
        SyncPark syncPark = new SyncPark(5);
        Thread t1 = new Thread(() -> syncPark.print("a"));
        Thread t2 = new Thread(() -> syncPark.print("b"));
        Thread t3 = new Thread(() -> syncPark.print("c\n"));
        syncPark.setThreads(t1, t2, t3);
        syncPark.start();
    }
}

class SyncPark {
    private final int total;
    private Thread[] threads;

    public SyncPark(int total) {
        this.total = total;
    }

    public void setThreads(Thread... threads) {
        this.threads = threads;
    }

    public void print(String string) {
        for (int i = 0; i < total; i++) {
            LockSupport.park();
            System.out.print(string);
            LockSupport.unpark(nextThread());
        }
    }

    private Thread nextThread() {
        Thread current = Thread.currentThread();
        int index = 0;
        for (int i = 0; i < threads.length; i++) {
            if (threads[i] == current) {
                index = i;
                break;
            }
        }
        if (index < threads.length - 1) {
            return threads[index + 1];
        } else {
            return threads[0];
        }
    }

    public void start() {
        for (Thread thread : threads) {
            thread.start();
        }
        LockSupport.unpark(threads[0]);
    }
}
```

## 阶段总结：

这块我们需要重点掌握的是：

- 分析多线程访问共享资源时，哪些代码片段属于临界区
- 使用 synchronized 互斥解决临界区的线程安全问题
  - 掌握 synchronized 锁对象语法
  - 掌握 synchronzied 加载成员方法和静态方法语法
  - 掌握 wait/notify 同步方法

- 使用 lock 互斥解决临界区的线程安全问题
  - 掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量

- 学会分析变量的线程安全性、掌握常见线程安全类的使用
- 了解线程活跃性问题：死锁、活锁、饥饿
- 应用方面
  - 互斥：使用 synchronized 或 Lock 达到共享资源互斥效果
  - 同步：使用 wait/notify 或 Lock 的条件变量来达到线程间通信效果

- 原理方面
  - monitor、synchronized 、wait/notify 原理
  - synchronized 进阶原理
  - park & unpark 原理

- 模式方面
  - 同步模式之保护性暂停
  - 异步模式之生产者消费者
  - 同步模式之顺序控制
