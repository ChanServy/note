本章内容：

- CAS 与 volatile
- 原子整数
- 原子引用
- 原子累加器
- Unsafe

## 1. 取款案例

其实主要就是保证取款的时候如果是高并发的情况的线程安全性。

### 1.1 不安全实现

```java
package com.chan.concurrent.cas;

/**
 * 账户接口
 */
public interface Account {
    // 获取余额
    Integer getBalance();

    // 取款
    void withdraw(Integer amount);
}

```

```java
package com.chan.concurrent.cas;
// 实现类
public class AccountImpl implements Account {
    // 余额
    private Integer balance;

    /**
     * 构造函数 初始化条件
     * @param balance 余额
     */
    public AccountImpl(Integer balance) {
        this.balance = balance;
    }

    /**
     * 余额
     * @return 余额
     */
    @Override
    public Integer getBalance() {
        return balance;
    }

    /**
     * 取款
     * @param amount 金额
     */
    @Override
    public void withdraw(Integer amount) {
        balance = balance - amount;
    }
}

```

```java
package com.chan.concurrent.cas;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;

/**
 * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
 * 如果初始余额为 10000 那么正确的结果应当是 0
 */
@Slf4j(topic = "c.Test")
public class Test {
    public static void main(String[] args) {
        Account account = new AccountImpl(10000);//账户起始10000元
        List<Thread> tasks = new ArrayList<>();
        long startTime = System.nanoTime();//起始时间
        for (int i = 0; i < 1000; i++) {//1000个线程循环加到集合容器
            tasks.add(new Thread(() -> account.withdraw(10)));//每个线程的任务是转出10元，1000*10=10000 正常最后余额为0
        }
        for (Thread task : tasks) {
            task.start();//循环启动这1000个线程
        }
        for (Thread task : tasks) {
            try {
                task.join(); //主线程等待所有的t线程执行完之后在向下进行
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        long endTime = System.nanoTime();//结束时间
        System.out.println(account.getBalance() + " cost:" + (endTime - startTime) / 1000000 + "ms");//结果
    }
}

```

```
530 cost:830ms
```

正常情况应该是余额为 0 。上面的实现，取款之后的余额是 530。 因为有很多个线程取款，出现了高并发的情况，造成了线程同步问题。

### 1.2 解决思路： 锁

```java
package com.chan.concurrent.cas.locksafe;

public class AccountImpl implements Account {
    //余额
    private Integer balance;

    public AccountImpl(Integer balance) {
        this.balance = balance;
    }

    /**
     * 得到余额
     * @return
     */
    @Override
    public synchronized Integer getBalance() {
        return balance;
    }


    /**
     * 取钱
     * @param amount
     */
    @Override
    public synchronized void withdraw(Integer amount) {
        balance = balance - amount;
    }
}

```

```
0 cost:299ms
```

### 1.3 解决思路： 无锁

```java
package com.chan.concurrent.cas.cassafe;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * 使用cas保证线程安全性
 */
public class AccountImpl implements Account {

    AtomicInteger balance;

    public AccountImpl(Integer balance) {
        this.balance = new AtomicInteger(10000);
    }

    @Override
    public Integer getBalance() {
        return balance.get();
    }

    @Override
    public void withdraw(Integer amount) {
        // 需要不断尝试，直到成功为止
        while (true) {
            // 比如拿到了旧值 1000
            int export = balance.get();
            // 在这个基础上 1000-10 = 990
            int next = export - amount;
            /*
            * 
            * compareAndSet 正是做这个检查，在 set 前，先比较 export 与当前主内存中的balance值
                 - 不一致了，next 作废，返回 false 表示失败
                 比如，别的线程已经做了减法，当前值已经被减成了 990
                 那么本线程的这次 990 就作废了，进入 while 下次循环重试
                 - 一致，以 next 设置为新值，返回 true 表示成功
            * 
            * */
            if (balance.compareAndSet(export, next)){
                break;
            }
        }
        // 可以简化为下面的方法
        // balance.addAndGet(-1 * amount);
    }
}

```

```
0 cost:366ms
```

## 2. CAS 与 volatile

前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？

```java
public void withdraw(Integer amount) {
    // 需要不断尝试，直到成功为止
    while (true) {
        // 比如拿到了旧值 1000
        int export = balance.get();
        // 在这个基础上 1000-10 = 990
        int next = export - amount;
        /*
            * 
            * compareAndSet 正是做这个检查，在 set 前，先比较 export 与当前主内存中的balance值
                 - 不一致了，next 作废，返回 false 表示失败
                 比如，别的线程已经做了减法，当前值已经被减成了 990
                 那么本线程的这次 990 就作废了，进入 while 下次循环重试
                 - 一致，以 next 设置为新值，返回 true 表示成功
            * 
            * */
        if (balance.compareAndSet(export, next)){
            break;
        }
    }
    // 可以简化为下面的方法
    // balance.addAndGet(-1 * amount);
}
```

上面案例的代码是不断尝试直到成功。 

其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。CAS 必须配合 volatile 才会发挥作用，底层代码中的共享变量，也就代表我们传入的参数，底层是通过 volatile 来修饰的。 部分源码：

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;

    /**
     * Creates a new AtomicInteger with the given initial value.
     *
     * @param initialValue the initial value
     */
    public AtomicInteger(int initialValue) {
        value = initialValue;
    }
    // ...
}
```

CAS 只有在多核 CPU 下对比起锁的实现才有明显的性能提升，并且线程数要少于 CPU 的核数性能提升显著。

### 2.1 volatile

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。

它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。

> volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，能保证有序性，也就是禁止本线程发生指令重排，但不能解决指令交错问题（不能保证原子性）

CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果。

### 2.2 为什么无锁效率高

- 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。
- 线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速。。。 恢复到高速运行，代价比较大
- 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换，不过总体上依然是无锁效率高。

### 2.3 CAS 的特点

结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。

- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。
- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。
- CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思
  - 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
  - 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响

## 3. 原子整数

J.U.C 并发包提供了：

- AtomicBoolean
- AtomicInteger
- AtomicLong

以 AtomicInteger 为例

```java
package com.chan.concurrent.cas.atomicIntegerExample;

import java.util.concurrent.atomic.AtomicInteger;

public class Test {
    public static void main(String[] args) {
        // 按需设置参数值 如果没有要求起始值为0
        AtomicInteger i = new AtomicInteger(0);// i = 0

        // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
        System.out.println(i.getAndIncrement());// 此时i = 1

        // 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
        System.out.println(i.incrementAndGet());// 此时i = 2

        // 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
        System.out.println(i.decrementAndGet());// 此时i = 1

        // 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
        System.out.println(i.getAndDecrement());// 此时i = 0

        // 获取并加值（i = 0, 结果 i = 5, 返回 0）
        System.out.println(i.getAndAdd(5));// 此时i = 5

        // 加值并获取（i = 5, 结果 i = 0, 返回 0）
        System.out.println(i.addAndGet(-5));// 此时i = 0

        // 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）
        System.out.println(i.getAndUpdate(p -> p - 2));// 此时i = -2 这个方法就可以随便运算了

        // 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）
        System.out.println(i.updateAndGet(p -> p + 2));// 此时i = 0

        // 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）
        // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的
        // getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final
        System.out.println(i.getAndAccumulate(10, (p, x) -> p + x));// 此时i = 10
//        System.out.println(i.getAndAccumulate(10, Integer::sum));// 此时i = 10
        
        // 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）
        System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x));// 此时i = 0
//        System.out.println(i.accumulateAndGet(-10, Integer::sum));// 此时i = 0
    }
}

```

## 4. 原子引用

为什么需要原子引用类型？

- AtomicReference
- AtomicStampedReference
- AtomicMarkableReference

上面的例子我们使用的是 Integer 类型，就是整数类型，这次使用 BigDecimal 引用类型实现。

### 4.1 不安全实现

```java
package com.chan.concurrent.cas.unsafeRef;

import java.math.BigDecimal;

/**
 * 账户接口
 */
public interface Account {
    // 获取余额
    BigDecimal getBalance();

    // 取款
    void withdraw(BigDecimal amount);
}

```

```java
package com.chan.concurrent.cas.unsafeRef;

import java.math.BigDecimal;

public class AccountImpl implements Account {
    // 余额
    private BigDecimal balance;

    /**
     * 构造函数 初始化条件
     * @param balance 余额
     */
    public AccountImpl(BigDecimal balance) {
        this.balance = balance;
    }

    /**
     * 余额
     * @return 余额
     */
    @Override
    public BigDecimal getBalance() {
        return balance;
    }

    /**
     * 取款
     * @param amount 金额
     */
    @Override
    public void withdraw(BigDecimal amount) {
        BigDecimal balance = this.getBalance();
        this.balance = balance.subtract(amount);
    }
}

```

```java
package com.chan.concurrent.cas.unsafeRef;

import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

/**
 * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
 * 如果初始余额为 10000 那么正确的结果应当是 0
 */
@Slf4j(topic = "c.Test")
public class Test {
    public static void main(String[] args) {
        Account account = new AccountImpl(BigDecimal.valueOf(10000));//账户起始10000元
        List<Thread> tasks = new ArrayList<>();
        long startTime = System.nanoTime();//起始时间
        for (int i = 0; i < 1000; i++) {//1000个线程循环加到集合容器
            tasks.add(new Thread(() -> account.withdraw(BigDecimal.TEN)));//每个线程的任务是转出10元，1000*10=10000 正常最后余额为0
        }
        for (Thread task : tasks) {
            task.start();//循环启动这1000个线程
        }
        for (Thread task : tasks) {
            try {
                task.join(); //主线程等待所有的t线程执行完之后在向下进行
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        long endTime = System.nanoTime();//结束时间
        System.out.println(account.getBalance() + " cost:" + (endTime - startTime) / 1000000 + "ms");//结果
    }
}

```

```
2700 cost:501ms
```

### 4.2 解决思路： 锁

```java
package com.chan.concurrent.cas.locksafeRef;

import java.math.BigDecimal;

public class AccountImpl implements Account {

    BigDecimal balance;
    final Object obj = new Object();

    public AccountImpl(BigDecimal balance) {
        this.balance = balance;
    }

    @Override
    public BigDecimal getBalance() {
        synchronized (obj) {
            return balance;
        }
    }

    @Override
    public void withdraw(BigDecimal amount) {
        synchronized (obj) {
            balance = balance.subtract(amount);
        }
    }
}

```

```
0 cost:374ms
```

### 4.3 解决思路： 无锁

```java
package com.chan.concurrent.cas.cassafeRef;

import java.math.BigDecimal;
import java.util.concurrent.atomic.AtomicReference;

public class AccountImpl implements Account {

    private AtomicReference<BigDecimal> balance;

    public AccountImpl(BigDecimal balance) {
        this.balance = new AtomicReference<>(balance);
    }

    @Override
    public BigDecimal getBalance() {
        return balance.get();
    }

    @Override
    public void withdraw(BigDecimal amount) {
        while (true) {
            BigDecimal perv = balance.get();
            BigDecimal next = perv.subtract(amount);
            if (balance.compareAndSet(perv, next)){
                break;
            }
        }
    }
}

```

```
0 cost:330ms
```

## 5. ABA 问题及解决

### 5.1 ABA 问题

```java
package com.chan.concurrent.cas.ABA;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
@Slf4j(topic = "c.Test")
public class Test {
    static AtomicReference<String> ref = new AtomicReference<>("A");

    public static void main(String[] args) throws InterruptedException {
        log.debug("main start...");
        // 获取值 A
        // 这个共享变量被它线程修改过？
        String prev = ref.get();
        otherThread();
        TimeUnit.SECONDS.sleep(2);
        log.debug("change A->C {}", ref.compareAndSet(prev, "C"));
    }

    public static void otherThread() throws InterruptedException {

        new Thread(new Runnable() {
            @Override
            public void run() {
                String prev = ref.get();
                log.debug("change A->B {}", ref.compareAndSet(prev, "B"));
            }
        }, "t1").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(new Runnable() {
            @Override
            public void run() {
                log.debug("change B->A {}", ref.compareAndSet(ref.get(), "A"));
            }
        }, "t2").start();
    }
}

```

输出：

```
17:21:35 [main] c.Test - main start...
17:21:35 [t1] c.Test - change A->B true
17:21:36 [t2] c.Test - change B->A true
17:21:38 [main] c.Test - change A->C true
```

主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望：

只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号。

### 5.2 AtomicStampedReference

```java
package com.chan.concurrent.cas.ABA;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.atomic.AtomicStampedReference;
@Slf4j(topic = "c.Test2")
public class Test2 {
    static AtomicStampedReference<String> ref = new AtomicStampedReference<>("A", 0);
    public static void main(String[] args) throws InterruptedException {
        log.debug("main start...");
        // 获取值 A
        String prev = ref.getReference();
        // 获取版本号
        int stamp = ref.getStamp();
        log.debug("版本 {}", stamp);
        // 如果中间有其它线程干扰，发生了 ABA 现象
        other();
        Thread.sleep(2000);
        // 尝试改为 C
        log.debug("change A->C {}", ref.compareAndSet(prev, "C", stamp, stamp + 1));
    }

    private static void other() throws InterruptedException {

        new Thread(() -> {
            log.debug("change A->B {}", ref.compareAndSet(ref.getReference(), "B", ref.getStamp(), ref.getStamp() + 1));
            log.debug("更新版本为 {}", ref.getStamp());
        }, "t1").start();

        Thread.sleep(1000);

        new Thread(() -> {
            log.debug("change B->A {}", ref.compareAndSet(ref.getReference(), "A", ref.getStamp(), ref.getStamp() + 1));
            log.debug("更新版本为 {}", ref.getStamp());
        }, "t2").start();
    }
}

```

```
17:35:48 [main] c.Test2 - main start...
17:35:48 [main] c.Test2 - 版本 0
17:35:48 [t1] c.Test2 - change A->B true
17:35:48 [t1] c.Test2 - 更新版本为 1
17:35:49 [t2] c.Test2 - change B->A true
17:35:49 [t2] c.Test2 - 更新版本为 2
17:35:51 [main] c.Test2 - change A->C false
```

AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -> B -> A -> C ，通过AtomicStampedReference，另外我们可以知道，引用变量中途被更改了几次。

但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 AtomicMarkableReference

### 5.3 AtomicMarkableReference

注释掉打扫卫生线程代码和不注释相比较，观察输出

```java
package com.chan.concurrent.cas.ABA;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.atomic.AtomicMarkableReference;
@Slf4j(topic = "c.TestABAAtomicMarkableReference")
public class TestABAAtomicMarkableReference {
    public static void main(String[] args) throws InterruptedException {
        GarbageBag bag = new GarbageBag("装满了垃圾");
        // 参数2 mark 可以看作一个标记，表示垃圾袋满了
        AtomicMarkableReference<GarbageBag> ref = new AtomicMarkableReference<>(bag, true);
        log.debug("主线程 start...");
        GarbageBag prev = ref.getReference();
        log.debug(prev.toString());

//        new Thread(() -> {
//            log.debug("打扫卫生的线程 start...");
//            bag.setDesc("空垃圾袋");
//            while (!ref.compareAndSet(bag, bag, true, false)) {}
//            log.debug(bag.toString());
//        }).start();

        Thread.sleep(1000);
        log.debug("主线程想换一只新垃圾袋？");
        boolean success = ref.compareAndSet(prev, new GarbageBag("空垃圾袋"), true, false);
        log.debug("换了么？" + success);
        log.debug(ref.getReference().toString());
    }
}

class GarbageBag {
    String desc;

    public GarbageBag(String desc) {
        this.desc = desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    @Override
    public String toString() {
        return "GarbageBag{" +
                "desc='" + desc + '\'' +
                '}';
    }
}

```

输出

```
17:57:42 [main] c.TestABAAtomicMarkableReference - 主线程 start...
17:57:42 [main] c.TestABAAtomicMarkableReference - GarbageBag{desc='装满了垃圾'}
17:57:43 [main] c.TestABAAtomicMarkableReference - 主线程想换一只新垃圾袋？
17:57:43 [main] c.TestABAAtomicMarkableReference - 换了么？true
17:57:43 [main] c.TestABAAtomicMarkableReference - GarbageBag{desc='空垃圾袋'}
```

```java
package com.chan.concurrent.cas.ABA;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.atomic.AtomicMarkableReference;
@Slf4j(topic = "c.TestABAAtomicMarkableReference")
public class TestABAAtomicMarkableReference {
    public static void main(String[] args) throws InterruptedException {
        GarbageBag bag = new GarbageBag("装满了垃圾");
        // 参数2 mark 可以看作一个标记，表示垃圾袋满了
        AtomicMarkableReference<GarbageBag> ref = new AtomicMarkableReference<>(bag, true);
        log.debug("主线程 start...");
        GarbageBag prev = ref.getReference();
        log.debug(prev.toString());

        new Thread(() -> {
            log.debug("打扫卫生的线程 start...");
            bag.setDesc("空垃圾袋");
            while (!ref.compareAndSet(bag, bag, true, false)) {}
            log.debug(bag.toString());
        }).start();

        Thread.sleep(1000);
        log.debug("主线程想换一只新垃圾袋？");
        boolean success = ref.compareAndSet(prev, new GarbageBag("空垃圾袋"), true, false);
        log.debug("换了么？" + success);
        log.debug(ref.getReference().toString());
    }
}

class GarbageBag {
    String desc;

    public GarbageBag(String desc) {
        this.desc = desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    @Override
    public String toString() {
        return "GarbageBag{" +
                "desc='" + desc + '\'' +
                '}';
    }
}

```

输出

```
17:59:42 [main] c.TestABAAtomicMarkableReference - 主线程 start...
17:59:42 [main] c.TestABAAtomicMarkableReference - GarbageBag{desc='装满了垃圾'}
17:59:42 [Thread-0] c.TestABAAtomicMarkableReference - 打扫卫生的线程 start...
17:59:42 [Thread-0] c.TestABAAtomicMarkableReference - GarbageBag{desc='空垃圾袋'}
17:59:43 [main] c.TestABAAtomicMarkableReference - 主线程想换一只新垃圾袋？
17:59:43 [main] c.TestABAAtomicMarkableReference - 换了么？false
17:59:43 [main] c.TestABAAtomicMarkableReference - GarbageBag{desc='空垃圾袋'}
```

目的就是保证垃圾袋是空的，线程 t 就好比把垃圾到了，垃圾袋没换，主线程就是将垃圾袋整个换成新的垃圾袋，这两种做法都可以保证垃圾袋是空的，上面的代码，主线程在换垃圾袋之前睡了一秒，所以是 t 线程先执行完倒垃圾，但是倒垃圾并不是换一个新的垃圾袋，因此还是之前的旧的对象，当主线程执行的时候，如果按照一般的 CAS 思路，比较并替换，我们知道引用类型的对象比较的是对象的内存地址，我们的垃圾袋对象一直没变，因此是符合置换要求的可以替换，因此这时主线程又用new GarbageBag("空垃圾袋")，去替换了prev，但是实际上有意义么? 是没意义的，因为我们的垃圾袋已经是空的了，需求已经达成，就不需要再去换一个新的垃圾袋了，所以我们这个时候使用的是 `AtomicMarkableReference` 类，设置了一个标记，倒垃圾之后将标记更改，等主线程来了想要换垃圾袋的时候查看标记，如果标记垃圾袋已经为空了，那就不用再换新的垃圾袋了。

## 6. 原子数组

- AtomicIntegerArray 整数 Integer 类型的数组
- AtomicLongArray 整数 Long 类型的数组
- AtomicReferenceArray 引用类型的数组，String 或者自定义类等

### 6.1 不安全的数组

**函数式接口**： 

在下面实现了一个通用的比较方法(demo)，让 LongAdder 对象 和 AtomicLong 对象 都使用这同一个方法的流程，保证公平性。
Supplier接口 和 Consumer接口 都是 函数式接口（即有且仅有一个抽象方法，但是可以有多个非抽象方法的接口）
Supplier接口的抽象方法可作为提供者，不传入参数，但返回结果；
Consumer接口的抽象方法可作为消费者，传入一个参数，但不返回结果。

```java
package com.chan.concurrent.cas.atomicArray;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

public class Test {
    public static void main(String[] args) {
        // 不安全的数组
        demo(
                () -> new int[10],
                (array) -> array.length,
                (array, index) -> array[index]++,
                (array) -> System.out.println(Arrays.toString(array))
        );
    }


    /**
     * 参数1，提供数组、可以是线程不安全数组或线程安全数组
     * 参数2，获取数组长度的方法
     * 参数3，自增方法，传 array, index
     * 参数4，打印数组的方法
     */
    // 函数式接口 接口中定义一个方法
    // supplier 提供者 无中生有 ()->结果
    // function 函数 一个参数一个结果 (参数)->结果 , BiFunction (参数1,参数2)->结果
    // consumer 消费者 一个参数没结果 (参数)->void, BiConsumer (参数1,参数2)->
    private static <T> void demo(
            Supplier<T> arraySupplier,
            Function<T, Integer> lengthFun,
            BiConsumer<T, Integer> putConsumer,
            Consumer<T> printConsumer
    ) {
        List<Thread> threads = new ArrayList<>();
        T array = arraySupplier.get();
        int length = lengthFun.apply(array);
        for (int i = 0; i < length; i++) {
            // 一共length个线程,每个线程对数组作 10000 次操作
            threads.add(new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 10000; j++) {
                        putConsumer.accept(array, j % length);
                    }
                }
            }));
        }
        for (Thread thread : threads) { // 启动所有线程
            thread.start();
        }
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } // 等所有线程结束
        printConsumer.accept(array);
    }
}

```

```
[8958, 8925, 8936, 8947, 8959, 8944, 8934, 8939, 8960, 8972]
```

### 6.2 安全的数组

```java
package com.chan.concurrent.cas.atomicArray;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicIntegerArray;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

public class Test2 {
    public static void main(String[] args) {
        // 安全的数组
        demo(
                () -> new AtomicIntegerArray(10),
                (array) -> array.length(),
                (array, index) -> array.getAndIncrement(index),
                (array) -> System.out.println(array)
        );
    }


    /**
     * 参数1，提供数组、可以是线程不安全数组或线程安全数组
     * 参数2，获取数组长度的方法
     * 参数3，自增方法，传 array, index
     * 参数4，打印数组的方法
     */
    // supplier 提供者 无中生有 ()->结果
    // function 函数 一个参数一个结果 (参数)->结果 , BiFunction (参数1,参数2)->结果
    // consumer 消费者 一个参数没结果 (参数)->void, BiConsumer (参数1,参数2)->
    private static <T> void demo(
            Supplier<T> arraySupplier,
            Function<T, Integer> lengthFun,
            BiConsumer<T, Integer> putConsumer,
            Consumer<T> printConsumer
    ) {
        List<Thread> threads = new ArrayList<>();
        T array = arraySupplier.get();
        int length = lengthFun.apply(array);
        for (int i = 0; i < length; i++) {
            // 一共length个线程,每个线程对数组作 10000 次操作
            threads.add(new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 10000; j++) {
                        putConsumer.accept(array, j % length);
                    }
                }
            }));
        }
        for (Thread thread : threads) {
            thread.start();
        }
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        printConsumer.accept(array);
    }
}

```

```
[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]
```

## 7. 字段更新器

- AtomicReferenceFieldUpdater  域字段是引用类型
- AtomicIntegerFieldUpdater 域字段是整数类型
- AtomicLongFieldUpdater

利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常

```
Exception in thread "main" java.lang.IllegalArgumentException: Must be volatile type
```

代码：

```java
package com.chan.concurrent.cas.atomicFieldUpdater;

import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public class Test {
    private volatile int field;

    public static void main(String[] args) {

        // AtomicIntegerFieldUpdater 处理int类型的字段的原子性
        AtomicIntegerFieldUpdater<Test> fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Test.class, "field");
        Test test = new Test();
        boolean a = fieldUpdater.compareAndSet(test, 0, 10);//返回布尔值 为true则将新的值设置 为false则保持旧值不变
        System.out.println(a);// 修改成功 field = 10
        System.out.println(test.field);

        boolean b = fieldUpdater.compareAndSet(test, 10, 20);
        System.out.println(b);// 修改成功 field = 20
        System.out.println(test.field);

        boolean c = fieldUpdater.compareAndSet(test, 10, 30);
        System.out.println(c);// 修改失败 field = 20
        System.out.println(test.field);



        // AtomicReferenceFieldUpdater 处理引用类型的字段的原子性
        AtomicReferenceFieldUpdater<Student, String> updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");
        Student student = new Student();
        boolean d = updater.compareAndSet(student, null, "陈陈陈");
        System.out.println(d);// 修改成功 name = "陈陈陈"
        System.out.println(student);

    }


}

class Student {
    volatile String name;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```
true
10
true
20
false
20
true
Student{name='陈陈陈'}
```

## 8. 原子累加器

### 8.1 累加器性能比较

比较 AtomicLong 与 LongAdder

```java
package com.chan.concurrent.cas.longAdder;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;
import java.util.function.Consumer;
import java.util.function.Supplier;

public class Test {
    public static void main(String[] args) {
        // 比较 AtomicLong 与 LongAdder
        for (int i = 0; i < 5; i++) {
            demo(() -> new AtomicLong(), (adder) -> adder.incrementAndGet());
        }

        for (int i = 0; i < 5; i++) {
            demo(() -> new LongAdder(), (adder) -> adder.increment());
        }
    }



    private static  <T> void demo(Supplier<T> supplier, Consumer<T> consumer) {
        T adder = supplier.get();// adder为共享变量
        List<Thread> threads = new ArrayList<>();
        long start = System.nanoTime();

        // 4 个线程，每个线程都去主内存中拿adder, 每个线程对adder各累加 50 万, 在线程安全的情况下, adder最后应该是2000000
        for (int i = 0; i < 4; i++) {
            threads.add(new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 500000; j++) {
                        consumer.accept(adder);
                    }
                }
            }));
        }
        for (Thread thread : threads) {
            thread.start();
        }
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        long end = System.nanoTime();
        System.out.println(adder + " cost:" + (end - start)/1000000 + "ms");
    }
}

```

```
2000000 cost:298ms
2000000 cost:253ms
2000000 cost:229ms
2000000 cost:221ms
2000000 cost:235ms
2000000 cost:69ms
2000000 cost:29ms
2000000 cost:28ms
2000000 cost:29ms
2000000 cost:22ms
```

### 8.2 性能提升的原因

如果使用 AtomicLong 实现累加，底层是 cas 思想，在多线程竞争时，它要使用 while(true) 循环不断尝试更新，直到能成功，但是竞争如果比较激烈，往一个共享变量上做累加，必然竞争比较激烈，重试的次数越多，累加的速率越低。 

如果使用 LongAdder 实现累加，它是在有竞争的时候设置多个累加单元，不是在一个共享变量上累加，这样比如 Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]。。。 线程 1 向共享变量 1 上累加，线程 2 向共享变量 2 上累加，最后将结果汇总。这样它们在累加时操作的不同的共享变量 Cell 变量(累加单元)，因此减少了 CAS 失败重试的次数，从而提高性能。这个增加累加单元的思想很像 forkjoin。

累加单元与 CPU 的核数有关，再多不会超过 CPU 的核数，因为超了核心数的话，CAS 便意义不大了。 所以核心数越多，性能越好。 

### 8.3 LongAdder源码剖析

LongAdder 是并发大师 @author Doug Lea 的作品，设计的非常精巧。

前面介绍的 Java 中的一些原子类，基本都是通过 CAS 来实现原子性操作，白白浪费 CPU 资源。JDK8 中新增了一个原子性递增或者递减类 LongAdder 用来克服高并发下使用 AtomicLong 的缺点。LongAdder 的思路是**把一个变量分解为多个变量，让同样多的线程去竞争多个资源**。

首先，LongAdder 类有几个关键域。 LongAdder继承自Striped64，在Striped64中维护者三个变量：base、cellsBusy、Cell数组。base是个基础知识，默认为0。cellsBusy用来实现自旋锁，状态值只有0和1，当创建Cell元素，扩容Cell数组或者初始化Cell数组时，使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。所以cells是volatile的，但没有加锁，而是用的自旋锁。

```java
// 累加单元数组, 懒惰初始化, 有竞争的时候用
transient volatile Cell[] cells;
// 基础值, 如果没有竞争, 则用 cas 累加这个域
transient volatile long base;
// 在 cells 创建或扩容时, 置为 1, 表示加锁
transient volatile int cellsBusy;
```

使用LongAdder时，内部维护了多个Cell变量(多个累加单元)，每个Cell里面有一个初始值为0的long型变量，这样同时竞争一个变量的线程数量就变少了，而是所有线程分散成对多个变量的竞争，减少了失败次数。**如果竞争某个Cell变量失败，它不会一直在这个Cell变量上自旋CAS重试，而是尝试在其他的Cell变量上进行CAS尝试**，这个改变增加了当前线程重试CAS成功的可能性。**最后，在获取LongAdder当前值时，是把所有Cell变量的value值累加后再加上base返回的**。

LongAdder里面有一个**Cell数组，是惰性加载的，即需要时创建**。当并发线程较少时，所有累加操作都是针对base变量进行。Cell类型是AtomicLong的一个改进，用来减少缓存的争用，也就是解决伪共享问题。因为Cell数组元素的内存地址是连续的，所以数组内的多个元素能经常共享缓存行，因此这里使用@sun.misc.Contended注解对Cell类进行字节填充，防止数组中多个元素共享一个缓存行，提升性能。

transient ： 序列化时不会把这些进行序列化

LongAdder 源码底层用到 cas 加锁，也即是 cellsBusy 为 1 的标记加锁，这种机制来保护 cells 创建或扩容时的安全。

下面的代码不要用在项目中，因为是有风险的，空运转可能导致对性能的影响。

#### 8.3.1 cas 锁 demo

LongAdder 里面就是使用了 cas 方式实现的锁，所以在这里预演一个 demo，方便理解 cellsBusy 的实现。

```java
package com.chan.concurrent.cas.longAdder;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

// 使用cas思想实现的锁, 这个方式拿不到锁不是阻塞而是一直循环, 不要用于生产实践
@Slf4j(topic = "c.CasLock")
public class CasLock {
    // 初始值设置为0
    AtomicInteger ai = new AtomicInteger(0);//状态只有0和1

    public void lock() {
        while (true) {
            int prev = ai.get();// 期望值为0
            int next = 1;// 新值
            if (ai.compareAndSet(prev, next)) {
                break;
            }
        }
    }

    public void unlock() {
        log.debug("unlock...");
        ai.set(0);
    }
}

@Slf4j(topic = "c.CasLockTest")
class CasLockTest {
    public static void main(String[] args) {
        CasLock casLock = new CasLock();

        new Thread(() -> {
            log.debug("begin...");
            casLock.lock();// 使用cas实现的锁, 要么成功拿到锁向下执行, 要么空转一直循环尝试, 这里就不叫阻塞了, 而是一直尝试,自旋锁 
            try {
                log.debug("lock...");
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                casLock.unlock();
            }
        }, "t1").start();

        new Thread(() -> {
            log.debug("begin...");
            casLock.lock();
            try {
                log.debug("lock...");
            } finally {
                casLock.unlock();
            }
        }, "t2").start();

    }
}
```

```
输出：
21:46:54 [t2] c.CasLockTest - begin...
21:46:54 [t2] c.CasLockTest - lock...
21:46:54 [t1] c.CasLockTest - begin...
21:46:54 [t2] c.CasLock - unlock...
21:46:54 [t1] c.CasLockTest - lock...
21:46:55 [t1] c.CasLock - unlock...
```

#### 8.3.2 LongAdder 源码分析

接下来的的解析都围绕着六个问题来进行：

1. LongAdder的结构是怎样的？
2. 线程访问Cell数组的哪一个Cell元素？
3. 如何初始化Cell数组？
4. Cell数组如何扩容？
5. 线程访问分配的Cell元素有冲突后如何处理？
6. 如何保证线程操作被分配的Cell元素的原子性？

```java
 	// 比较 AtomicLong 与 LongAdder
    for (int i = 0; i < 5; i++) {
        demo(() -> new AtomicLong(), (adder) -> adder.incrementAndGet());
    }
    for (int i = 0; i < 5; i++) {
        demo(() -> new LongAdder(), (adder) -> adder.increment());
    }
```

我们从 adder.increment() 的方法点进去

```java
    /**
     * Equivalent to {@code add(1)}.
     */
    public void increment() {
        add(1L);
    }
```

再点 add 方法进到里面：

```java
    /**
     * Adds the given value.
     *
     * @param x the value to add
     */
    public void add(long x) {
        Cell[] as; long b, v; int m; Cell a;
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[getProbe() & m]) == null ||
                !(uncontended = a.cas(v = a.value, v + x)))
                longAccumulate(x, null, uncontended);
        }
    }
```

先不看别的，再点击 longAccumulate 方法进到里面：

提前说明一下源码中的几个方法

```java
int getProbe() //方法，用来获得线程对应的probe值，类似于hash值，是一种hash函数映射。
int advanceProbe(int probe) //方法：用来重新生成一个probe值，为什么要重新生成呢？因为在之前的probe映射到的cell中累加，一直失败。

boolean casCellsBusy() //方法：用来上cas锁 ——— 上锁成功则返回true，此时cellsBusy应为1；上锁失败则返回false，证明有其他线程正在使用锁；使用锁结束后，应该让cellsBusy = 0，变成无锁状态。

```

源码：

```java
 /**
     * Handles cases of updates involving initialization, resizing,
     * creating new Cells, and/or contention. See above for
     * explanation. This method suffers the usual non-modularity
     * problems of optimistic retry code, relying on rechecked sets of
     * reads.
     *
     * @param x the value
     * @param fn the update function, or null for add (this convention
     * avoids the need for an extra field or function in LongAdder).
     * @param wasUncontended false if CAS failed before call
     */
    //都有哪些情况会调用？
    //1.true-> cells 未初始化，也就是多线程写base发生竞争了[初始化cells]
    //         执行CASE2
    //2.true-> cells 已初始化，但是当前线程对应下标的cell为空，需要创建 longAccumulate 支持
    //         执行CASE1.1
    //3.true-> cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]
    //         执行CASE1.3 失败 -> CASE1.5 -> rehash，即执行advanceProbe(h) -> 自旋 -> 执行CASE1.3 再失败 -> CASE1.6()因为CASE1.5中将设置扩容意向为true

    // wasUncontended：只有cells初始化之后，并且当前线程 竞争修改失败，才会是false
    final void longAccumulate(long x, LongBinaryOperator fn,
                              boolean wasUncontended) {
        //h 表示线程hash值
        int h;
        //条件成立：说明当前线程 还未分配hash值
        if ((h = getProbe()) == 0) {
            //给当前线程分配hash值
            ThreadLocalRandom.current(); // force initialization
            //取出当前线程的hash值 赋值给h
            h = getProbe();
            //为什么wasUncontended设置为true？
            //代码执行到这里，说明线程没有分配hash值(hash=0)
            //所以 当前线程 肯定是写入到了 cells[0] 位置(0 & 任意数 = 0)。 不把它当做一次真正的竞争
            wasUncontended = true;
        }

        //表示扩容意向。 false 一定不会扩容；true 可能会扩容。
        boolean collide = false;                // True if last slot nonempty

        //自旋
        for (;;) {
            //as 表示cells引用
            //a 表示当前线程命中的cell
            //n 表示cells数组长度
            //v 表示 期望值
            Cell[] as; Cell a; int n; long v;

            //CASE1： 表示cells已经初始化了，当前线程应该将数据写入到对应的cell中
            if ((as = cells) != null && (n = as.length) > 0) {
                //进入这个if，有下面两种情况
                //2.true-> 说明当前线程对应下标的cell为空，需要创建 longAccumulate 支持
                //3.true->表示cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]

                //CASE1.1：true->表示当前线程对应的下标位置的cell为null，需要创建new Cell
                if ((a = as[(n - 1) & h]) == null) {

                    //true->表示当前锁 未被占用； false->表示锁被占用
                    if (cellsBusy == 0) {       // Try to attach new Cell

                        //拿当前的x创建Cell
                        Cell r = new Cell(x);   // Optimistically create

                        //条件一：true->表示当前锁 未被占用； false->表示锁被占用
                        //条件二：true->表示当前线程获取锁成功； false->当前线程获取锁失败。
                        if (cellsBusy == 0 && casCellsBusy()) {
                            //是否创建成功的标记
                            boolean created = false;
                            try {               // Recheck under lock
                                //rs 表示当前cells 引用
                                //m 表示cells长度
                                //j 表示当前线程命中的下标
                                Cell[] rs; int m, j;

                                //条件一 条件二 为true
                                //条件三：rs[j = (m - 1) & h] == null 为了防止其它线程初始化过该位置，然后当前线程再次初始化该位置，导致丢失数据
                                if ((rs = cells) != null &&
                                        (m = rs.length) > 0 &&
                                        rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }

                    //扩容意向 强制改为了false
                    collide = false;
                }
                // CASE1.2：true -> wasUncontended：只有cells初始化之后，并且当前线程 竞争修改失败，才会是false
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                //CASE 1.3：当前线程rehash过hash值，然后新命中的cell不为空
                //true -> 写成功,退出循环
                //false -> 表示rehash之后命中的新的cell 也有竞争
                else if (a.cas(v = a.value, ((fn == null) ? v + x :
                        fn.applyAsLong(v, x))))
                    break;
                //CASE 1.4：
                //条件一：n >= NCPU 为 true->就会把扩容意向改为false，不再扩容； false-> 说明cells数组还可以扩容
                //条件二：cells != as 为 true->其它线程已经扩容过了，当前线程rehash之后重试即可
                else if (n >= NCPU || cells != as)
                    //扩容意向为false，表示不扩容了
                    collide = false;            // At max size or stale
                //CASE 1.5：
                //!collide == true 设置扩容意向 为true 但是不一定真的发生扩容
                else if (!collide)
                    collide = true;
                //CASE 1.6：真正扩容的逻辑
                //条件一：cellsBusy == 0 true->表示当前无锁状态，当前线程可以去竞争这把锁
                //条件二：casCellsBusy true->表示当前线程 获取锁 成功，可以执行扩容逻辑
                // false->表示当前时刻有其它线程在做扩容相关的操作。
                else if (cellsBusy == 0 && casCellsBusy()) {
                    try {
                        //这里又判断了一次cells == as。  防止其它线程已经扩容了，当前线程再次扩容。cells的引用就会发生变化，导致数据流失
                        if (cells == as) {      // Expand table unless stale
                            //数组长度扩容，得到新数组，新长度等于旧长度左移1位，等价于 新长度=旧长度*2
                            Cell[] rs = new Cell[n << 1];
                            //遍历旧数组，将旧数组对应位置的值放到新数组中
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            //将新数组的引用赋值给全局的cells
                            cells = rs;
                        }
                    } finally {
                        //释放锁
                        cellsBusy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }

                //修改失败，就会重置当前线程Hash值，然后当前线程自旋，再次修改时，就会到不同的cell上
                h = advanceProbe(h);
            }
            //CASE2：前置条件cells还未初始化，as 为null
            //条件一：true 表示当前未加锁
            //条件二：为什么cells == as？短路原则，当判断这个条件时，条件一为true，表示其他线程已经持有锁了
            //       那么其它线程在执行下面的初始化方法，可能会在你给as赋值为null之后修改了 cells，所以这里再判断一次
            //条件三：true 表示获取锁成功 会把cellsBusy = 1，false 表示其它线程正在持有这把锁
            else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
                boolean init = false;
                try {                           // Initialize table
                    //这里又判断了一次cells == as。  防止其它线程已经初始化了，当前线程再次初始化 导致丢失数据
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
            //CASE3：前面两个if中所有条件都为false才会执行到这，说明：
            //1.当前cellsBusy加锁状态，表示其它线程正在初始化cells，所以当前线程将值累加到base
            //2.cells被其它线程初始化后，当前线程需要将数据累加到base
            else if (casBase(v = base, ((fn == null) ? v + x :
                    fn.applyAsLong(v, x))))
                break;                          // Fall back on using base
        }
    }

```

现在是在 Striped64 类中，我们继续向上翻，找到学习 LongAdder 的核心以及出发点，也就是下面的 Cell 累加单元类. 为什么说它是核心以及出发点，我们都知道 LongAdder 和 AtomicLong 的功能是一样的都是累加，但是 LongAdder 的速率要高于 AtomicLong ，那么为什么比 AtomicLong 的速度快，就是因为 LongAdder 改进了可以增加累加单元，那累加单元类就是下面的：

```java
    /**
     * Padded variant of AtomicLong supporting only raw accesses plus CAS.
     *
     * JVM intrinsics note: It would be possible to use a release-only
     * form of CAS here, if it were provided.
     */
    @sun.misc.Contended static final class Cell {
        volatile long value;
        Cell(long x) { value = x; }
        final boolean cas(long cmp, long val) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }

        // Unsafe mechanics
        private static final sun.misc.Unsafe UNSAFE;
        private static final long valueOffset;
        static {
            try {
                UNSAFE = sun.misc.Unsafe.getUnsafe();
                Class<?> ak = Cell.class;
                valueOffset = UNSAFE.objectFieldOffset
                    (ak.getDeclaredField("value"));
            } catch (Exception e) {
                throw new Error(e);
            }
        }
    }
```

很简单，一个Cell维护一个volatile的变量，和Cell数组类似，这里设置成volatile但并没有加锁主要是利用了cas来保证内部value的原子性更改，这也回答了**问题6，即如何保证线程操作被分配的Cell元素的原子性** 。类Cell使用@sun.misc.Contended修饰是为了避免伪共享，因为Cell数组是连续的，很容易出现这种问题。我们也弄懂了**问题1，即LongAdder的结构是怎样的**。

#### 8.3.3 原理之伪共享

@sun.misc.Contended 看这个注解： 这个注解的作用就是为了防止**缓存行共享**

缓存行共享就是我们说的伪共享，要先从缓存说起。 

![](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_45.png)

| 从 CPU 到 | 大约需要的时钟周期               |
| --------- | -------------------------------- |
| 寄存器    | 1 cycle (4GHz 的 CPU 约为0.25ns) |
| L1        | 3~4 cycle                        |
| L2        | 10~20cycle                       |
| L3        | 40~45cycle                       |
| 主内存    | 120~240cycle                     |

因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。

而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long）

缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中

CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的**整个缓存行必须失效**

注： CPU 的三级缓存，为了方便在下图中统一画一个缓存行

![](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_46.png)

因为 Cell 是**数组形式，在内存中是连续存储的**，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因此缓存行可以存下 2 个的 Cell 对象。这样问题来了：

- Core-0 要修改 Cell[0]
- Core-1 要修改 Cell[1]

无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]=6000，Cell[1]=8000 要累加 Cell[0]=6001，Cell[1]=8000 ，这时会让 Core-1 的缓存行失效。

@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效。

![](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_47.png)

其实就是空间换取时间，让每个累加单元独占一个核心的缓存行。

我们将这种一个核心的缓存行中加入了多个累加单元的现象成为伪共享，一个改动，其它整体失效，其它都要重新加载，会影响效率，这个注解的作用就是防止伪共享。 提高效率。

接下来回过头来看前面的 add 方法，累加主要调用这个方法：

```java
        public void add(long x) {
            // as 为累加单元数组
            // b 为基础值
            // x 为累加值
            Cell[] as; long b, v; int m; Cell a;
            // 进入 if 的两个条件
            // 1. as 有值, 表示已经发生过竞争, 进入 if
            // 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if
            if ((as = cells) != null || !casBase(b = base, b + x)) {   		//(1)
                // uncontended 表示 cell 没有竞争
                boolean uncontended = true;
                if (
                    // as 还没有创建
                        as == null || (m = as.length - 1) < 0 ||            //(2)       
                                // 当前线程对应的 cell 还没有
                                (a = as[getProbe() & m]) == null ||			//(3)
                                // cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )
                                !(uncontended = a.cas(v = a.value, v + x))	//(4)
                ) {
                    // 进入 cell 数组创建、cell 创建的流程
                    longAccumulate(x, null, uncontended);					//(5)		
                }
            }
        }
```

要注意这个函数里面的判断条件虽然是或的关系，其实是层层递进的。

1. 代码（1）先看cells是否为null，如果不为空则直接执内部代码块，为空则先尝试在base变量上进行累加。
2. 如果累加base变量成功了，则直接返回，失败了则执行内部代码块。
3. 代码（2）如果cells是空的（as==null或者as的长度为0），则执行代码（5）进行累加；不为空则得到要当前线程要访问的cell（即变量a，下标是通过getProb() & m获取的）。
4. 如果要访问的cell为空，则执行代码（5），否则就对访问的cas进行原子改变操作，并返回uncontended变量查看是否执行成功，成功了直接返回，失败了还是要执行代码（5）。

这个地方我们就回答了**问题2，即如何知道当前线程是访问哪一个cell呢**，通过getProbe() & m获取下标，进而从cells数组中取得。m代表当前cells数组元素个数-1，getProbe()用于获取当前线程中变量threadLocalRandomProbe的值，它一开始为0，在代码5中会对其进行初始化。

接下来就是longAccumulate方法了，我们通过分析add方法的逻辑，知道了LongAdder中调用longAccumulate的原因：（三者之一）

1. cells 未初始化，但是多线程写base发生竞争了[进入longAccumulate初始化cells]
2. cells 已初始化，但是当前线程对应下标的cell为空，需要创建 longAccumulate 支持
3. cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]

- 情况一：说明 cells 未初始化，也就是多线程写base发生竞争了[初始化cells]，会进入case2，当前线程拿到锁并进入扩容；如果当前线程没有获取到锁或者其他线程已经初始化了，则进入case3，表示其它线程正在初始化cells，所以当前线程将值累加到base
- 情况二、情况三都会进入case1，表示cells已经初始化了，当前线程应该将数据写入到对应的cell中
  - 情况二：说明当前线程对应下标的cell为空，需要创建 longAccumulate 支持，进入case1.1，创建new Cell
  - 情况三：表示cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]
    - cell已经有了但是在写的时候发生了竞争，进入case1.2，这时wasUncontended为false，取反为true，进入该条件，将这个值设置为true，进行rehash
    - 自旋重新进入case1，cell不为空的话进入case1.3尝试一次，成功则退出自旋循环，否则进入case1.5，将collide设置为true，再次rehash，再次查看case1.3条件是否满足，不满足则会直接进入到case1.6，这里才是真正的扩容方法。

> 注意：这里的case1.4是累加单元数组的长度不能超过cpu核心的数量，因为我们要保证一个核心的缓存行对应一个累加单元。

```java
 /**
     * Handles cases of updates involving initialization, resizing,
     * creating new Cells, and/or contention. See above for
     * explanation. This method suffers the usual non-modularity
     * problems of optimistic retry code, relying on rechecked sets of
     * reads.
     *
     * @param x the value
     * @param fn the update function, or null for add (this convention
     * avoids the need for an extra field or function in LongAdder).
     * @param wasUncontended false if CAS failed before call
     */
    //都有哪些情况会调用？
    //1.true-> cells 未初始化，也就是多线程写base发生竞争了[初始化cells]
    //         执行CASE2
    //2.true-> cells 已初始化，但是当前线程对应下标的cell为空，需要创建 longAccumulate 支持
    //         执行CASE1.1
    //3.true-> cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]
    //         执行CASE1.3 失败 -> CASE1.5 -> rehash，即执行advanceProbe(h) -> 自旋 -> 执行CASE1.3 再失败 -> CASE1.6()因为CASE1.5中将设置扩容意向为true

    // wasUncontended：只有cells初始化之后，并且当前线程 竞争修改失败，才会是false
    final void longAccumulate(long x, LongBinaryOperator fn,
                              boolean wasUncontended) {
        //h 表示线程hash值
        int h;
        //条件成立：说明当前线程 还未分配hash值
        if ((h = getProbe()) == 0) {
            //给当前线程分配hash值
            ThreadLocalRandom.current(); // force initialization
            //取出当前线程的hash值 赋值给h
            h = getProbe();
            //为什么wasUncontended设置为true？
            //代码执行到这里，说明线程没有分配hash值(hash=0)
            //所以 当前线程 肯定是写入到了 cells[0] 位置(0 & 任意数 = 0)。 不把它当做一次真正的竞争
            wasUncontended = true;
        }

        //表示扩容意向。 false 一定不会扩容；true 可能会扩容。
        boolean collide = false;                // True if last slot nonempty

        //自旋
        for (;;) {
            //as 表示cells引用
            //a 表示当前线程命中的cell
            //n 表示cells数组长度
            //v 表示 期望值
            Cell[] as; Cell a; int n; long v;

            //CASE1： 表示cells已经初始化了，当前线程应该将数据写入到对应的cell中
            if ((as = cells) != null && (n = as.length) > 0) {
                //进入这个if，有下面两种情况
                //2.true-> 说明当前线程对应下标的cell为空，需要创建 longAccumulate 支持
                //3.true->表示cas失败，意味着当前线程对应的cell 有竞争[重试|扩容]

                //CASE1.1：true->表示当前线程对应的下标位置的cell为null，需要创建new Cell
                if ((a = as[(n - 1) & h]) == null) {

                    //true->表示当前锁 未被占用； false->表示锁被占用
                    if (cellsBusy == 0) {       // Try to attach new Cell

                        //拿当前的x创建Cell
                        Cell r = new Cell(x);   // Optimistically create

                        //条件一：true->表示当前锁 未被占用； false->表示锁被占用
                        //条件二：true->表示当前线程获取锁成功； false->当前线程获取锁失败。
                        if (cellsBusy == 0 && casCellsBusy()) {
                            //是否创建成功的标记
                            boolean created = false;
                            try {               // Recheck under lock
                                //rs 表示当前cells 引用
                                //m 表示cells长度
                                //j 表示当前线程命中的下标
                                Cell[] rs; int m, j;

                                //条件一 条件二 为true
                                //条件三：rs[j = (m - 1) & h] == null 为了防止其它线程初始化过该位置，然后当前线程再次初始化该位置，导致丢失数据
                                if ((rs = cells) != null &&
                                        (m = rs.length) > 0 &&
                                        rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }

                    //扩容意向 强制改为了false
                    collide = false;
                }
                // CASE1.2：true -> wasUncontended：只有cells初始化之后，并且当前线程 竞争修改失败，才会是false
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                //CASE 1.3：当前线程rehash过hash值，然后新命中的cell不为空
                //true -> 写成功,退出循环
                //false -> 表示rehash之后命中的新的cell 也有竞争
                else if (a.cas(v = a.value, ((fn == null) ? v + x :
                        fn.applyAsLong(v, x))))
                    break;
                //CASE 1.4：
                //条件一：n >= NCPU 为 true->就会把扩容意向改为false，不再扩容； false-> 说明cells数组还可以扩容
                //条件二：cells != as 为 true->其它线程已经扩容过了，当前线程rehash之后重试即可
                else if (n >= NCPU || cells != as)
                    //扩容意向为false，表示不扩容了
                    collide = false;            // At max size or stale
                //CASE 1.5：
                //!collide == true 设置扩容意向 为true 但是不一定真的发生扩容
                else if (!collide)
                    collide = true;
                //CASE 1.6：真正扩容的逻辑
                //条件一：cellsBusy == 0 true->表示当前无锁状态，当前线程可以去竞争这把锁
                //条件二：casCellsBusy true->表示当前线程 获取锁 成功，可以执行扩容逻辑
                // false->表示当前时刻有其它线程在做扩容相关的操作。
                else if (cellsBusy == 0 && casCellsBusy()) {
                    try {
                        //这里又判断了一次cells == as。  防止其它线程已经扩容了，当前线程再次扩容。cells的引用就会发生变化，导致数据流失
                        if (cells == as) {      // Expand table unless stale
                            //数组长度扩容，得到新数组，新长度等于旧长度左移1位，等价于 新长度=旧长度*2
                            Cell[] rs = new Cell[n << 1];
                            //遍历旧数组，将旧数组对应位置的值放到新数组中
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            //将新数组的引用赋值给全局的cells
                            cells = rs;
                        }
                    } finally {
                        //释放锁
                        cellsBusy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }

                //修改失败，就会重置当前线程Hash值，然后当前线程自旋，再次修改时，就会到不同的cell上
                h = advanceProbe(h);
            }
            //CASE2：前置条件cells还未初始化，as 为null
            //条件一：true 表示当前未加锁
            //条件二：为什么cells == as？短路原则，当判断这个条件时，条件一为true，表示其他线程已经持有锁了
            //       那么其它线程在执行下面的初始化方法，可能会在你给as赋值为null之后修改了 cells，所以这里再判断一次
            //条件三：true 表示获取锁成功 会把cellsBusy = 1，false 表示其它线程正在持有这把锁
            else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
                boolean init = false;
                try {                           // Initialize table
                    //这里又判断了一次cells == as。  防止其它线程已经初始化了，当前线程再次初始化 导致丢失数据
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
            //CASE3：前面两个if中所有条件都为false才会执行到这，说明：
            //1.当前cellsBusy加锁状态，表示其它线程正在初始化cells，所以当前线程将值累加到base
            //2.cells被其它线程初始化后，当前线程需要将数据累加到base
            else if (casBase(v = base, ((fn == null) ? v + x :
                    fn.applyAsLong(v, x))))
                break;                          // Fall back on using base
        }
    }

```

![](https://cdn.jsdelivr.net/gh/ChanServy/CDN2@master/concurrent/image/image_49.png)

```java
final void longAccumulate(long x, LongBinaryOperator fn,
                              boolean wasUncontended) {
        //(6) 初始化当前线程的变量threadLocalRandomProbe的值
        int h;
        if ((h = getProbe()) == 0) {
            ThreadLocalRandom.current(); // force initialization
            h = getProbe();
            wasUncontended = true;
        }
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null && (n = as.length) > 0) {	//(7)
                if ((a = as[(n - 1) & h]) == null) {	//(8)
                    if (cellsBusy == 0) {       // Try to attach new Cell
                        Cell r = new Cell(x);   // Optimistically create
                        if (cellsBusy == 0 && casCellsBusy()) {
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &&
                                    (m = rs.length) > 0 &&
                                    rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                //当前Cell存在，则执行CAS设置（9）
                else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                             fn.applyAsLong(v, x))))
                    break;
                //当前Cells数组元素个数大于CPU个数（10）
                else if (n >= NCPU || cells != as)
                    collide = false;            // At max size or stale
                else if (!collide)
                //是否有冲突（11）
                    collide = true;
                //如果当前元素个数没有达到CPU个数并且有冲突则扩容（12）
                else if (cellsBusy == 0 && casCellsBusy()) {
                    try {
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        cellsBusy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                //（13）为了能够找到一个空闲的Cell，重新计算hash值，xorshift算法生成随机数
                h = advanceProbe(h);
            }
            //初始化Cell数组（14）
            else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                    	//14.1
                        Cell[] rs = new Cell[2];
                        //14.2
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
            else if (casBase(v = base, ((fn == null) ? v + x :
                                        fn.applyAsLong(v, x))))
                break;                          // Fall back on using base
        }
    }

```

代码很长很复杂，这里我们还是针对开头提出的问题3、问题4、问题5。

- 问题3：如何初始化Cell数组？cells数组初始化是在代码（14）中进行的，cellsBusy是一个标示，为0说明当前cells数组没有在被初始化或者扩容，也没有在新建Cell元素（没有发生结构化改变），为1说明cells数组再被扩容、初始化或创建新的Cell元素，只有通过casCellsBusy()函数将cellsBusy变量成功由0设置为1才可继续初始化。然后就是申请数组空间，然后计算本线程要访问的cell下标，设置初始化标志，最后要重置cellsBusy标记。
- 问题4：Cell数组如何扩容？cells数组扩容是在代码（12）中进行的，对cells扩容是有条件的，也就是代码（10）（11）的条件都不满足，即当前cells的元素个数小于当前机器CPU个数并且当前多个线程访问了cells中同一个元素，从而导致冲突使其中一个线程CAS失败时才会进行扩容操作。因为最好让每个CPU只运行一个线程时效果最好，扩容也会进行casCellsBusy()操作。扩容后将原来的复制到新的数组中，剩余的还未初始化，为Null。
- 问题5：线程访问分配的Cell元素有冲突后如何处理？代码（7）（8）中，当前线程调用add方法并根据当前线程的随机数threadLocakRandomProbe和cells元素个数计算要访问的cell元素下标，然后如果发现对应下标元素的值为null，则新增一个Cell元素到cells数组，并且在将其添加到cells数组之前要竞争设置cellsBusy为1。代码（13）对CAS失败的线程重新计算当前线程的随机值threadLocalRandomProbe，以减少下次访问cells元素时的冲突机会。

## 9. Unsafe

Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。Unsafe 并不是指线程安全方面的不安全，而是指这个类比较底层，操作内存、线程，不建议我们编程人员直接对其使用，误用会导致不安全的发生，并不是指它本身是线程不安全的。前面介绍的所有的原子整数、原子引用这些原子类，它们的底层都是调用使用了 Unsafe，而 Unsafe 的底层调用了 CPU 的一些 cas 指令（以 lock 打头的一些指令）来保证比较和交换的原子性。

案例：

```java
package com.chan.concurrent.cas.baseUnsafe;

import lombok.Data;
import sun.misc.Unsafe;

import java.lang.reflect.Field;

public class UnsafeAccessor {
    // 这个对象普通获取不到 要通过反射获取
    static Unsafe unsafe;

    static {
        try {
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");// 反射获取Unsafe类中的字段
            theUnsafe.setAccessible(true);// 因为这个字段是private的域,所以要设置权限为true
            unsafe = (Unsafe) theUnsafe.get(null);// 因为这个字段是static的从属于类的因此参数传递null 111
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new Error(e);
        }
    }

    static Unsafe getUnsafe() {
        return unsafe;
    }

    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        Field id = Student.class.getDeclaredField("id");
        Field name = Student.class.getDeclaredField("name");
        Unsafe unsafe = UnsafeAccessor.getUnsafe();
        // 获得成员变量的偏移量
        long idOffset = UnsafeAccessor.unsafe.objectFieldOffset(id);
        long nameOffset = UnsafeAccessor.unsafe.objectFieldOffset(name);
        Student student = new Student();
        // 使用cas方法替换成员变量的值
        // 新建好的对象还没赋过值 所以旧值默认为0和null
        UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, 0, 20);// 返回true
        UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, null, "迩东陈");// 返回true
        System.out.println(student);
        System.out.println(id.get(student));// 因为这个字段不是static的,因此参数传递对象 222
        System.out.println(name.get(student));
    }
}

@Data
class Student {
    volatile int id;
    volatile String name;
}
```

```
Student(id=20, name=迩东陈)
20
迩东陈
```

前面的取款案例，现在再使用底层的 Unsafe 来实现一次线程安全的原子操作。如下：

```java
package com.chan.concurrent.cas.baseUnsafe;

import lombok.extern.slf4j.Slf4j;
import sun.misc.Unsafe;

import java.lang.reflect.Field;

@Slf4j(topic = "c.AtomicData")
public class AtomicData {

    private volatile int data;
    static final Unsafe unsafe;
    static final long DATA_OFFSET;

    static {
        try {
            // 先获取unsafe
            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
            theUnsafe.setAccessible(true);
            unsafe = (Unsafe) theUnsafe.get(null);//通过反射得到unsafe对象
            // 获取变量的偏移量
            Field dataField = AtomicData.class.getDeclaredField("data");
            DATA_OFFSET = unsafe.objectFieldOffset(dataField);//得到data的偏移量
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new Error(e);//重点 一定注意！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
        }
    }

    public AtomicData(int data) {
        this.data = data;
    }

    public void decrease(int amount) {
        while (true) {
            //从主存中拿到共享变量的旧值
            int prev = data;
            //计算新值
            int next = prev - amount;
            //cas 尝试修改 data 为 旧值 - amount，如果期间旧值被别的线程改了，返回 false
            if (unsafe.compareAndSwapInt(this, DATA_OFFSET, prev, next)) {
                break;
            }
        }
    }

    public int getData() {
        return data;
    }
}

```

```java
package com.chan.concurrent.cas.baseUnsafe;

import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List<Thread> threads = new ArrayList<>();
        AtomicData atomicData = new AtomicData(10000);
        long startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            threads.add(new Thread(new Runnable() {
                @Override
                public void run() {
                    atomicData.decrease(10);
                }
            }));
        }
        for (Thread thread : threads) {
            thread.start();
        }
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        long endTime = System.nanoTime();
        System.out.println(atomicData.getData() + " cost:" + (endTime - startTime) / 1000000 + "ms");
    }
}

```

```java
0 cost:277ms
```

## 本章小结

- CAS 与 volatile
- API
  - 原子整数
  - 原子引用
  - 原子数组
  - 字段更新器
  - 原子累加器
- Unsafe
- 原理方面
  - LongAdder源码
  - 伪共享
